// Configuration centralis√©e des APIs
const API_CONFIG = {
  // APIs Quran
  GITHUB: "https://cdn.jsdelivr.net/gh/AlfaazPlus/QuranApp@latest/",
  QURAN: "https://api.quran.com/",
  ALQURAN_CLOUD: "https://api.alquran.cloud/v1/",
  ALQURAN_AUDIO: "https://cdn.islamic.network/quran/audio/128/",
  
  // APIs M√©t√©o et Pri√®res
  WEATHER: "https://api.openweathermap.org/data/2.5",
  WEATHER_KEY: '886705b4c1182eb1c69f28eb8c520e20',
  PRAYER_CITY: "https://api.aladhan.com/v1/timingsByCity",
  PRAYER_COORDINATES: "https://api.aladhan.com/v1/timings",
  
  // API Hadiths
  HADITH: 'https://hadeethenc.com/api/v1',
  
  // Timeouts et retry configuration
  DEFAULT_TIMEOUT: 30000,
  DEFAULT_RETRIES: 3,
  CACHE_DURATION: 1800000 // 30 minutes
};

// R√©trocompatibilit√© pour le code existant
const GITHUB_API_URL = API_CONFIG.GITHUB;
const QURAN_API_URL = API_CONFIG.QURAN;
const ALQURAN_CLOUD_API = API_CONFIG.ALQURAN_CLOUD;
const ALQURAN_AUDIO_URL = API_CONFIG.ALQURAN_AUDIO;
const WEATHER_API_URL = API_CONFIG.WEATHER;
const WEATHER_API_KEY = API_CONFIG.WEATHER_KEY;
const PRAYER_API_URL = API_CONFIG.PRAYER_CITY;
const PRAYER_API_URL_COORDINATES = API_CONFIG.PRAYER_COORDINATES;

// Electron IPC pour communication avec le processus principal
const { ipcRenderer } = require('electron');

// √âcouter l'√©v√©nement pour afficher la section √Ä propos depuis le menu
ipcRenderer.on('show-about', () => {
  // V√©rifier si la fonction showAboutSection est disponible
  if (typeof showAboutSection === 'function') {
    showAboutSection();
  }
});

// DOM Elements
const loadSurahsButton = document.getElementById("load-surahs");
const surahListElement = document.getElementById("surah-list");
const quranContentElement = document.getElementById("quran-content");
const searchInput = document.getElementById("search-input");
const surahInfoElement = document.getElementById("surah-info");
const audioPlayerElement = document.getElementById("audio-player");
const progressBarElement = document.getElementById("progress-bar");
const audioProgressElement = document.getElementById("audio-progress");
const playButton = document.getElementById("play-button");
const pauseButton = document.getElementById("pause-button");
const reciterSelect = document.getElementById("reciter-select");
const translationSelect = document.getElementById("translation-select");
const currentTimeElement = document.getElementById("current-time");
const durationElement = document.getElementById("duration");
const verseInfoElement = document.getElementById("verse-info");
const previousVerseButton = document.getElementById("previous-verse");
const nextVerseButton = document.getElementById("next-verse");
const repeatVerseButton = document.getElementById("repeat-verse");
const volumeSlider = document.getElementById("volume-slider");
const themeToggle = document.getElementById("theme-toggle");
const currentTimeDisplay = document.getElementById('current-time');
const durationDisplay = document.getElementById('duration');

// DOM Elements pour le lecteur am√©lior√©
const playButtonMain = document.getElementById("play-button-main");
const pauseButtonMain = document.getElementById("pause-button-main");
const equalizerElement = document.querySelector(".equalizer");
const miniPlayer = document.getElementById("mini-player");
const miniSurahName = document.getElementById("mini-surah-name");
const miniVerseNumber = document.getElementById("mini-verse-number");
const miniProgressBar = document.getElementById("mini-progress-bar");
const miniPlay = document.getElementById("mini-play");
const miniPrev = document.getElementById("mini-prev");
const miniNext = document.getElementById("mini-next");

// √âl√©ments du DOM pour la m√©t√©o
let weatherModal = null;
let weatherToggle = null;
let weatherModalClose = null;

// √âl√©ments du DOM pour les pri√®res
let prayerModal = null;
let prayerToggle = null;
let prayerModalClose = null;
let prayerLocationInput = null;
let prayerLocationSearch = null;

// Configuration de la m√©t√©o
let userLocation = {
  latitude: null,
  longitude: null,
  city: 'Chargement...'
};

// Configuration pour les horaires de pri√®re
let prayerSettings = {
  city: '',
  country: 'FR',
  method: 2, // Islamic Society of North America (ISNA)
  latitude: null,
  longitude: null
};

// Initialisation de la m√©t√©o
function initWeather() {
  // S'assurer que tous les √©l√©ments du DOM sont r√©cup√©r√©s
  weatherModal = document.getElementById('weather-modal');
  weatherToggle = document.getElementById('weather-toggle');
  weatherModalClose = document.getElementById('weather-modal-close');
  
  // Ajouter du d√©bogage
  const debugInfo = document.getElementById('debug-info');
  if (debugInfo) {
    debugInfo.innerText = `Modal: ${!!weatherModal}, Toggle: ${!!weatherToggle}, Close: ${!!weatherModalClose}`;
  }
  
  if (!weatherModal || !weatherToggle || !weatherModalClose) {
    console.error('√âl√©ments de la m√©t√©o introuvables dans le DOM');
    return;
  }
  
  // √âv√©nement pour fermer la modale m√©t√©o
  weatherModalClose.addEventListener('click', () => {
    console.log('Fermeture de la modale m√©t√©o');
    weatherModal.classList.remove('active');
  });

  // Fermer la modale si on clique en dehors
  weatherModal.querySelector('.ios-modal-backdrop').addEventListener('click', () => {
    weatherModal.classList.remove('active');
  });
  
  // √âv√©nement pour ouvrir la modale m√©t√©o
  weatherToggle.addEventListener('click', () => {
    console.log('Ouverture de la modale m√©t√©o');
    weatherModal.classList.add('active');
    
    // Mettre √† jour l'heure imm√©diatement √† l'ouverture
    updateSystemTime();
    
    // Rafra√Æchir les donn√©es si elles datent de plus de 30 minutes
    const cachedTimestamp = localStorage.getItem('weatherTimestamp');
    const currentTime = new Date().getTime();
    
    if (!cachedTimestamp || (currentTime - cachedTimestamp > 1800000)) {
      getUserLocation();
    }
  });
  
  console.log('M√©t√©o initialis√©e avec succ√®s');
  
  // Pr√©charger les donn√©es m√©t√©o en arri√®re-plan d√®s le chargement de la page
  setTimeout(() => {
    getUserLocation();
  }, 1000); // D√©lai de 1 seconde pour ne pas bloquer le chargement initial de la page
}

// Obtenir la localisation de l'utilisateur
function getUserLocation() {
  // Afficher un texte de chargement rapide
  document.querySelector('.city-name').textContent = 'Chargement...';
  document.querySelector('.weather-desc').textContent = 'R√©cup√©ration rapide...';
  
  const debugInfo = document.getElementById('debug-info');
  
  // V√©rifier si on a des donn√©es m√©t√©o en cache
  const cachedWeatherData = localStorage.getItem('weatherData');
  const cachedTimestamp = localStorage.getItem('weatherTimestamp');
  const currentTime = new Date().getTime();
  
  // Si on a des donn√©es en cache qui datent de moins de 30 minutes (1800000 ms), les utiliser
  if (cachedWeatherData && cachedTimestamp && (currentTime - cachedTimestamp < 1800000)) {
    try {
      const weatherData = JSON.parse(cachedWeatherData);
      if (debugInfo) {
        debugInfo.innerText = "Utilisation des donn√©es en cache";
      }
      
      // Mettre √† jour l'interface avec les donn√©es en cache
      updateWeatherInterface(weatherData.current, weatherData.forecast);
      return;
    } catch (error) {
      console.error('Erreur lors de la lecture du cache:', error);
      // Continuer pour r√©cup√©rer de nouvelles donn√©es
    }
  }
  
  // Si on a d√©j√† des coordonn√©es, les utiliser directement
  if (userLocation.latitude && userLocation.longitude) {
    console.log("R√©utilisation des coordonn√©es existantes:", userLocation);
    if (debugInfo) {
      debugInfo.innerText = `Appel API: ${userLocation.latitude.toFixed(2)}, ${userLocation.longitude.toFixed(2)}`;
    }
    getWeatherData(userLocation.latitude, userLocation.longitude);
    return;
  }
  
  // Utiliser une position par d√©faut (Paris) pour un chargement initial rapide
  userLocation.latitude = 48.8566;
  userLocation.longitude = 2.3522;
  getWeatherData(48.8566, 2.3522);
  
  // Ensuite tenter la g√©olocalisation en arri√®re-plan pour mettre √† jour ult√©rieurement
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        // Si la position est diff√©rente de celle par d√©faut, mettre √† jour
        if (Math.abs(position.coords.latitude - userLocation.latitude) > 0.01 ||
            Math.abs(position.coords.longitude - userLocation.longitude) > 0.01) {
          userLocation.latitude = position.coords.latitude;
          userLocation.longitude = position.coords.longitude;
          
          if (debugInfo) {
            debugInfo.innerText += ` | Position r√©elle: ${position.coords.latitude.toFixed(2)}, ${position.coords.longitude.toFixed(2)}`;
          }
          
          // R√©cup√©rer les donn√©es m√©t√©o avec les coordonn√©es r√©elles
          getWeatherData(userLocation.latitude, userLocation.longitude);
        }
      },
      (error) => {
        console.warn('Erreur de g√©olocalisation:', error);
        if (debugInfo) {
          debugInfo.innerText += ` | G√©oloc non disponible: ${error.code}`;
        }
      },
      {
        // Options de g√©olocalisation avec timeout court
        timeout: 5000,
        maximumAge: 300000 // 5 minutes
      }
    );
  } else {
    console.warn('La g√©olocalisation n\'est pas support√©e par ce navigateur');
    if (debugInfo) {
      debugInfo.innerText += " | G√©oloc non support√©e";
    }
  }
}

// R√©cup√©rer les donn√©es m√©t√©o - Version am√©lior√©e
async function getWeatherData(lat, lon) {
  const debugInfo = document.getElementById('debug-info');
  
  try {
    console.log(`üå§Ô∏è R√©cup√©ration des donn√©es m√©t√©o pour: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
    
    if (debugInfo) {
      debugInfo.innerText = `Appel API m√©t√©o: ${lat.toFixed(2)}, ${lon.toFixed(2)}`;
    }
    
    // V√©rifier le cache en premier
    const cacheKey = `weather_${lat.toFixed(2)}_${lon.toFixed(2)}`;
    const cachedData = CacheManager.getLocalStorage(cacheKey, API_CONFIG.CACHE_DURATION);
    
    if (cachedData) {
      console.log('‚úÖ Donn√©es m√©t√©o r√©cup√©r√©es du cache');
      updateWeatherInterface(cachedData.current, cachedData.forecast);
      if (debugInfo) {
        debugInfo.innerText += ' | Cache OK';
      }
      return;
    }
    
    // URLs des APIs m√©t√©o
    const currentWeatherUrl = `${API_CONFIG.WEATHER}/weather?lat=${lat}&lon=${lon}&units=metric&lang=fr&appid=${API_CONFIG.WEATHER_KEY}`;
    const forecastUrl = `${API_CONFIG.WEATHER}/forecast?lat=${lat}&lon=${lon}&units=metric&lang=fr&appid=${API_CONFIG.WEATHER_KEY}`;
    
    // R√©cup√©rer les donn√©es en parall√®le avec gestion d'erreurs am√©lior√©e
    const [currentWeatherData, forecastData] = await Promise.all([
      fetchApi(currentWeatherUrl, { context: 'm√©t√©o actuelle', showUIError: false }),
      fetchApi(forecastUrl, { context: 'pr√©visions m√©t√©o', showUIError: false })
    ]);
    
    if (!currentWeatherData || !forecastData) {
      throw new Error('Donn√©es m√©t√©o incompl√®tes');
    }
    
    console.log('‚úÖ Donn√©es m√©t√©o r√©cup√©r√©es avec succ√®s');
    
    if (debugInfo) {
      debugInfo.innerText += ` | M√©t√©o OK: ${currentWeatherData.name}`;
    }
    
    // Sauvegarder en cache
    const weatherBundle = {
      current: currentWeatherData,
      forecast: forecastData
    };
    
    CacheManager.setLocalStorage(cacheKey, weatherBundle);
    CacheManager.memory.weather = weatherBundle;
    
    // Mettre √† jour l'interface
    updateWeatherInterface(currentWeatherData, forecastData);
    
  } catch (error) {
    ErrorHandler.log(error, 'M√©t√©o');
    
    if (debugInfo) {
      debugInfo.innerText += ` | Erreur: ${error.message}`;
    }
    
    // Strat√©gie de r√©cup√©ration: essayer le cache m√™me expir√©
    const cacheKey = `weather_${lat.toFixed(2)}_${lon.toFixed(2)}`;
    const staleCache = CacheManager.getLocalStorage(cacheKey, Infinity); // Ignorer l'expiration
    
    if (staleCache) {
      console.log('üîÑ Utilisation cache m√©t√©o expir√© en fallback');
      updateWeatherInterface(staleCache.current, staleCache.forecast);
      if (debugInfo) {
        debugInfo.innerText += ' | Cache expir√© utilis√©';
      }
      return;
    }
    
    // Dernier recours
    displayWeatherError();
  }
}

// Renommer cette fonction pour √©viter les conflits 
function updateWeatherInterface(current, forecast) {
  // Utiliser un DocumentFragment pour r√©duire les manipulations du DOM
  const fragment = document.createDocumentFragment();
  
  // Mettre √† jour les informations de la ville
  document.querySelector('.city-name').textContent = current.name;
  
  // Mettre √† jour la description m√©t√©o
  document.querySelector('.weather-desc').textContent = capitalizeFirstLetter(current.weather[0].description);
  
  // Mettre √† jour l'ic√¥ne m√©t√©o principale - seulement si elle a chang√©
  const iconCode = current.weather[0].icon;
  const iconUrl = `https://openweathermap.org/img/wn/${iconCode}@4x.png`;
  const iconElement = document.querySelector('.weather-icon-large');
  if (iconElement.src !== iconUrl) {
    iconElement.src = iconUrl;
  }
  
  // Mettre √† jour la temp√©rature
  document.querySelector('.main-temp').textContent = `${Math.round(current.main.temp)}¬∞`;
  
  // Mettre √† jour la temp√©rature ressentie
  document.querySelector('.feels-like').textContent = `Ressenti: ${Math.round(current.main.feels_like)}¬∞`;
  
  // Mettre √† jour les d√©tails (humidit√© et vent)
  const humidityValue = document.querySelector('.humidity-detail .detail-value');
  const windValue = document.querySelector('.wind-detail .detail-value');
  
  if (humidityValue) {
    humidityValue.textContent = `${current.main.humidity}%`;
  }
  
  if (windValue) {
    windValue.textContent = `${Math.round(current.wind.speed * 3.6)} km/h`; // Conversion de m/s en km/h
  }
  
  // Mettre √† jour la qualit√© de l'air (d√©pend de l'API - ici on utilise des valeurs simplifi√©es)
  updateAirQuality(current);
  
  // Mettre √† jour les pr√©visions pour les prochains jours de fa√ßon efficace
  updateForecastEfficient(forecast);
}

// Version optimis√©e de updateForecast
function updateForecastEfficient(forecastData) {
  if (!forecastData || !forecastData.list) return;
  
  // Pr√©parer un objet pour stocker les pr√©visions quotidiennes (on prend la valeur √† midi)
  const dailyForecasts = {};
  
  // Traitement des donn√©es de pr√©vision (regrouper par jour)
  forecastData.list.forEach(item => {
    const date = new Date(item.dt * 1000);
    const day = date.toLocaleDateString('fr-FR', { weekday: 'long' });
    
    // On v√©rifie si c'est une pr√©vision autour de midi (entre 11h et 14h)
    const hour = date.getHours();
    if (hour >= 11 && hour <= 14 && !dailyForecasts[day]) {
      dailyForecasts[day] = item;
    }
  });
  
  // Obtenir les 4 prochains jours
  const forecastDays = Object.keys(dailyForecasts).slice(0, 4);
  
  // Mettre √† jour l'interface pour chaque jour de pr√©vision
  const forecastItems = document.querySelectorAll('.forecast-item');
  
  forecastDays.forEach((day, index) => {
    if (index < forecastItems.length && dailyForecasts[day]) {
      const forecast = dailyForecasts[day];
      const forecastItem = forecastItems[index];
      
      // Jour de la semaine (premier jour devient "Demain")
      const dayText = index === 0 ? 'Demain' : capitalizeFirstLetter(day);
      const dayElement = forecastItem.querySelector('.forecast-day');
      if (dayElement.textContent !== dayText) {
        dayElement.textContent = dayText;
      }
      
      // Ic√¥ne m√©t√©o - seulement si elle a chang√©
      const iconCode = forecast.weather[0].icon;
      const iconUrl = `https://openweathermap.org/img/wn/${iconCode}.png`;
      const iconElement = forecastItem.querySelector('.forecast-icon-img');
      if (iconElement.src !== iconUrl) {
        iconElement.src = iconUrl;
      }
      
      // Temp√©rature
      const tempText = `${Math.round(forecast.main.temp)}¬∞`;
      const tempElement = forecastItem.querySelector('.forecast-temp');
      if (tempElement.textContent !== tempText) {
        tempElement.textContent = tempText;
      }
    }
  });
}

// Mettre √† jour les indicateurs de qualit√© d'air, UV et pollen
function updateAirQuality(currentWeather) {
  // Donn√©es simplifi√©es - dans une application r√©elle, vous auriez besoin d'APIs suppl√©mentaires pour ces informations
  
  // UV index estimation bas√©e sur la couverture nuageuse
  const clouds = currentWeather.clouds.all;
  let uvLevel, uvText;
  
  if (clouds < 30) {
    uvLevel = 'high';
    uvText = '√âlev√©';
  } else if (clouds < 70) {
    uvLevel = 'moderate';
    uvText = 'Mod√©r√©';
  } else {
    uvLevel = 'low';
    uvText = 'Faible';
  }
  
  // Pollution estimation bas√©e sur la zone (urbaine/rurale) - simplifi√©e
  const isUrbanArea = currentWeather.name.includes('Paris') || currentWeather.name.includes('Lyon') || currentWeather.name.includes('Marseille');
  let pollutionLevel, pollutionText;
  
  if (isUrbanArea) {
    pollutionLevel = 'moderate';
    pollutionText = 'Mod√©r√©';
  } else {
    pollutionLevel = 'low';
    pollutionText = 'Faible';
  }
  
  // Pollen estimation bas√©e sur la saison - simplifi√©e
  const month = new Date().getMonth();
  let pollenLevel, pollenText;
  
  // Printemps/√©t√© = pollen √©lev√©
  if (month >= 2 && month <= 7) {
    pollenLevel = 'high';
    pollenText = '√âlev√©';
  } else if (month === 1 || month === 8) {
    pollenLevel = 'moderate';
    pollenText = 'Mod√©r√©';
  } else {
    pollenLevel = 'low';
    pollenText = 'Faible';
  }
  
  // Mettre √† jour l'interface
  const qualityItems = document.querySelectorAll('.quality-item');
  
  // UV
  updateQualityBadge(qualityItems[0], uvLevel, uvText);
  
  // Pollution
  updateQualityBadge(qualityItems[1], pollutionLevel, pollutionText);
  
  // Pollen
  updateQualityBadge(qualityItems[2], pollenLevel, pollenText);
}

// Mettre √† jour un badge de qualit√©
function updateQualityBadge(item, level, text) {
  const badge = item.querySelector('.quality-badge');
  
  // Supprimer toutes les classes de niveau
  badge.classList.remove('low', 'moderate', 'high');
  
  // Ajouter la classe appropri√©e
  badge.classList.add(level);
  
  // Mettre √† jour le texte
  badge.textContent = text;
}

// Afficher une erreur en cas de probl√®me avec l'API m√©t√©o
function displayWeatherError() {
  document.querySelector('.city-name').textContent = 'Erreur';
  document.querySelector('.weather-desc').textContent = 'Impossible de charger les donn√©es m√©t√©o';
  document.querySelector('.main-temp').textContent = '--¬∞';
  document.querySelector('.feels-like').textContent = 'Ressenti: --¬∞';
  
  // R√©initialiser les autres √©l√©ments
  document.querySelector('.humidity-detail .detail-value').textContent = '--';
  document.querySelector('.wind-detail .detail-value').textContent = '--';
  
  // R√©initialiser les indicateurs de qualit√©
  const qualityItems = document.querySelectorAll('.quality-item');
  qualityItems.forEach(item => {
    const badge = item.querySelector('.quality-badge');
    badge.className = 'quality-badge';
    badge.classList.add('low');
    badge.textContent = '--';
  });
  
  // R√©initialiser les pr√©visions
  const forecastItems = document.querySelectorAll('.forecast-item');
  forecastItems.forEach(item => {
    item.querySelector('.forecast-day').textContent = '--';
    item.querySelector('.forecast-temp').textContent = '--¬∞';
  });
}

// Utilitaire pour mettre en majuscule la premi√®re lettre
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// Gestion du th√®me (mode clair/sombre)
function toggleTheme() {
  const currentTheme = localStorage.getItem('theme') || 'light';
  const newTheme = currentTheme === 'light' ? 'dark' : 'light';
  
  // Supprimer l'approche avec la classe theme-changing qui cause des saccades
  // document.body.classList.add('theme-changing');
  
  // Changer directement le th√®me sans animation
  document.documentElement.setAttribute('data-theme', newTheme);
  localStorage.setItem('theme', newTheme);
  
  // Supprimer le timeout qui √©tait utilis√© pour la fin de l'animation
  // setTimeout(() => {
  //   document.body.classList.remove('theme-changing');
  // }, 300); // L√©g√®rement plus long que la dur√©e de la transition pour √™tre s√ªr
  
  // Mettre √† jour l'UI pour le bouton de th√®me
  if (newTheme === 'dark') {
    themeToggle.setAttribute('title', 'Passer en mode clair');
  } else {
    themeToggle.setAttribute('title', 'Passer en mode sombre');
  }
  
  console.log(`Th√®me chang√© en: ${newTheme}`);
}

// Initialiser le th√®me √† partir de localStorage
function initTheme() {
  // R√©cup√©rer le th√®me sauvegard√© ou utiliser 'light' par d√©faut
  const savedTheme = localStorage.getItem('theme') || 'light';
  
  // Appliquer le th√®me directement sans transition
  document.documentElement.setAttribute('data-theme', savedTheme);
  
  // Mettre √† jour le titre du bouton de th√®me
  if (savedTheme === 'dark') {
    themeToggle.setAttribute('title', 'Passer en mode clair');
  } else {
    themeToggle.setAttribute('title', 'Passer en mode sombre');
  }

  // Ajouter l'√©couteur d'√©v√©nement pour le toggle
  themeToggle.addEventListener('click', toggleTheme);
  
  console.log(`Th√®me initialis√©: ${savedTheme}`);
}

// Ajouter un √©couteur d'√©v√©nement pour le bouton de th√®me
themeToggle.addEventListener('click', toggleTheme);

// Initialiser le th√®me
initTheme();

// R√©citateurs disponibles sur Alquran.cloud (garantis de fonctionner)
const RECITERS = [
  { name: 'Mishary Rashid Al-Afasy', identifier: 'ar.alafasy' },
  { name: 'Abdurrahman As-Sudais', identifier: 'ar.abdurrahmaansudais' },
  { name: 'Saud Al-Shuraim', identifier: 'ar.saoodshuraym' },
  { name: 'Saad Al-Ghamdi', identifier: 'ar.saadalghamdi' },
  { name: 'Maher Al-Muaiqly', identifier: 'ar.maheralmuaiqly' },
  { name: 'Ali Al-Hudhaify', identifier: 'ar.hudhaify' },
  { name: 'Ahmed ibn Ali al-Ajamy', identifier: 'ar.ahmedajamy' },
  { name: 'Muhammad Ayyoub', identifier: 'ar.muhammadayyoub' },
  { name: 'Abdul Basit Abdul Samad', identifier: 'ar.abdulbasitmurattal' },
  { name: 'Muhammad Siddiq Al-Minshawi', identifier: 'ar.minshawi' },
  { name: 'Mahmoud Khalil Al-Husary', identifier: 'ar.husary' },
  { name: 'Abu Bakr Ash-Shatri', identifier: 'ar.shaatree' },
  { name: 'Hani Ar-Rifai', identifier: 'ar.hanirifai' },
  { name: 'Youssouf Leclerc (Fran√ßais)', identifier: 'fr.leclerc' }
];

// Traductions disponibles
const TRANSLATIONS = [
  { name: 'Sans traduction', identifier: 'none' },
  { name: 'Fran√ßais', identifier: '31' },
  { name: 'Anglais', identifier: '20' },
  { name: 'Espagnol', identifier: '83' },
  { name: 'Allemand', identifier: '27' },
  { name: 'Italien', identifier: '34' }
];

// Mettre √† jour les options de r√©citateurs
function updateReciterOptions() {
  reciterSelect.innerHTML = '';
  RECITERS.forEach((reciter) => {
    const option = document.createElement('option');
    option.value = reciter.identifier;
    option.textContent = reciter.name;
    reciterSelect.appendChild(option);
  });
  
  // Supprimer l'ancien event listener et en ajouter un nouveau
  reciterSelect.removeEventListener("change", handleReciterChange);
  reciterSelect.addEventListener("change", handleReciterChange);
  
  // Restaurer la pr√©f√©rence de r√©citateur sauvegard√©e
  const savedReciter = localStorage.getItem('preferredReciter');
  if (savedReciter && reciterSelect.querySelector(`option[value="${savedReciter}"]`)) {
    reciterSelect.value = savedReciter;
  }
}

// Gestionnaire pour le changement de r√©citateur
function handleReciterChange() {
  const selectedReciter = RECITERS.find(r => r.identifier === reciterSelect.value);
  localStorage.setItem('preferredReciter', reciterSelect.value);
  
  if (selectedReciter) {
    // Afficher une notification √©l√©gante
    showReciterNotification(selectedReciter);
  }
  
  if (currentSurah && currentVerse) {
    // Continuer la lecture √† partir du verset actuel avec le nouveau r√©citateur
    playVerseAudio(currentVerse);
  }
}

// Notification moderne et √©l√©gante pour le changement de r√©citateur
function showReciterNotification(reciter) {
  // Supprimer une √©ventuelle notification existante
  const existingNotification = document.getElementById('reciter-notification');
  if (existingNotification) {
    existingNotification.remove();
  }
  
  // Cr√©er la nouvelle notification
  const notification = document.createElement('div');
  notification.id = 'reciter-notification';
  
  // Style moderne avec effet glass et transparence
  notification.style.cssText = `
    position: fixed;
    top: 80px;
    right: 20px;
    width: 280px;
    padding: 16px 20px;
    
    /* Style glass moderne */
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    
    /* Animation et transition */
    opacity: 0;
    transform: translateX(100%) scale(0.9);
    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    
    /* Style du texte */
    color: var(--text-color);
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
    font-size: 14px;
    line-height: 1.4;
    
    /* Z-index √©lev√© */
    z-index: 10000;
    
    /* Curseur pointer pour indiquer l'interactivit√© */
    cursor: pointer;
    
    /* Emp√™cher la s√©lection de texte */
    user-select: none;
    -webkit-user-select: none;
  `;
  
  // Contenu de la notification avec ic√¥ne et informations
  notification.innerHTML = `
    <div style="display: flex; align-items: center; gap: 12px;">
      <div style="
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
      ">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="white" style="opacity: 0.9;">
          <path d="M12 3V21M9 19L12 21L15 19M9 5L12 3L15 5M5 9L3 12L5 15M19 9L21 12L19 15" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          <circle cx="12" cy="12" r="3" stroke="white" stroke-width="2" fill="none"/>
        </svg>
      </div>
      <div style="flex: 1; min-width: 0;">
        <div style="
          font-weight: 600;
          font-size: 15px;
          margin-bottom: 2px;
          color: var(--text-color);
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        ">${reciter.name}</div>
        <div style="
          font-size: 12px;
          opacity: 0.7;
          color: var(--text-color);
        ">R√©citateur s√©lectionn√©</div>
      </div>
      <div style="
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s ease;
      " onclick="this.closest('#reciter-notification').remove()">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </div>
    </div>
  `;
  
  // Adaptation pour le mode sombre
  const updateThemeStyles = () => {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    if (isDark) {
      notification.style.background = 'rgba(28, 28, 30, 0.8)';
      notification.style.border = '1px solid rgba(255, 255, 255, 0.1)';
      notification.style.color = '#ffffff';
    } else {
      notification.style.background = 'rgba(255, 255, 255, 0.1)';
      notification.style.border = '1px solid rgba(255, 255, 255, 0.2)';
      notification.style.color = 'var(--text-color)';
    }
  };
  
  updateThemeStyles();
  
  // Ajouter au DOM
  document.body.appendChild(notification);
  
  // Animation d'apparition
  requestAnimationFrame(() => {
    notification.style.opacity = '1';
    notification.style.transform = 'translateX(0) scale(1)';
  });
  
  // Effet de hover pour la fermeture
  const closeButton = notification.querySelector('[onclick]');
  closeButton.addEventListener('mouseenter', () => {
    closeButton.style.background = 'rgba(255, 255, 255, 0.2)';
  });
  closeButton.addEventListener('mouseleave', () => {
    closeButton.style.background = 'rgba(255, 255, 255, 0.1)';
  });
  
  // Fermeture automatique apr√®s 4 secondes
  const autoClose = setTimeout(() => {
    if (notification.parentElement) {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(100%) scale(0.9)';
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 400);
    }
  }, 4000);
  
  // Fermeture au clic sur la notification
  notification.addEventListener('click', (e) => {
    if (e.target === notification || e.target.closest('.notification-content')) {
      clearTimeout(autoClose);
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(100%) scale(0.9)';
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 400);
    }
  });
  
  // Pause de l'auto-fermeture au survol
  notification.addEventListener('mouseenter', () => {
    clearTimeout(autoClose);
  });
  
  // Reprendre l'auto-fermeture en quittant le survol
  notification.addEventListener('mouseleave', () => {
    const newAutoClose = setTimeout(() => {
      if (notification.parentElement) {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%) scale(0.9)';
        setTimeout(() => {
          if (notification.parentElement) {
            notification.remove();
          }
        }, 400);
      }
    }, 2000);
  });
}



// Mettre √† jour les options de traduction
function updateTranslationOptions() {
  translationSelect.innerHTML = '';
  TRANSLATIONS.forEach((translation) => {
    const option = document.createElement('option');
    option.value = translation.identifier;
    option.textContent = translation.name;
    translationSelect.appendChild(option);
  });
  
  // Sauvegarder la pr√©f√©rence de traduction dans localStorage
  translationSelect.addEventListener("change", () => {
    localStorage.setItem('preferredTranslation', translationSelect.value);
    if (currentSurah) {
      // Recharger la sourate pour appliquer la nouvelle traduction
      loadSurah(currentSurah.id);
    }
  });
  
  // Restaurer la pr√©f√©rence de traduction sauvegard√©e
  const savedTranslation = localStorage.getItem('preferredTranslation');
  if (savedTranslation && translationSelect.querySelector(`option[value="${savedTranslation}"]`)) {
    translationSelect.value = savedTranslation;
  } else {
    // Par d√©faut, utiliser la traduction fran√ßaise
    translationSelect.value = '31';
  }
}

// Afficher l'√©l√©ment audio pour le d√©bogage
audioPlayerElement.style.display = "block";

// State variables
let currentSurah = null;
let currentVerse = null;
let allSurahs = [];
let audioQueue = [];
let isPlaying = false;
let highlightInterval = null;
let surahCache = {}; // Cache pour stocker les sourates d√©j√† charg√©es
let lastPlayedIndex = -1; // Garder une trace de l'index du dernier verset jou√©

// Variables globales pour la gestion du pr√©chargement avanc√©
let nextAudioElement = new Audio(); // √âl√©ment audio pour le prochain verset
let futureAudioElement = new Audio(); // √âl√©ment audio pour le verset d'apr√®s
let isPreloadingNext = false;
let preloadedVerses = {}; // Cache pour les versets pr√©charg√©s

// Variables globales pour le t√©l√©chargement en arri√®re-plan
let downloadInProgress = false;
let currentDownloadSurahId = null;
let downloadProgress = 0;
let downloadAbortController = null;

// Gestionnaire de cache avanc√©
const CacheManager = {
  // Configuration du cache
  CONFIG: {
    MAX_SURAHS: 5,          // Nombre maximum de sourates en cache
    MAX_AUDIO_CACHE: 3,      // Nombre maximum d'audios en cache
    CACHE_DURATION: 3600000,  // 1 heure en millisecondes
    STORAGE_PREFIX: 'playouran_'
  },
  
  // Cache en m√©moire
  memory: {
    surahs: new Map(),
    audio: new Map(),
    weather: null,
    prayers: null,
    hadiths: new Map()
  },
  
  // Ajouter au cache avec gestion automatique de la taille
  setSurah(id, data) {
    if (this.memory.surahs.size >= this.CONFIG.MAX_SURAHS) {
      // Supprimer la plus ancienne entr√©e
      const firstKey = this.memory.surahs.keys().next().value;
      this.memory.surahs.delete(firstKey);
    }
    this.memory.surahs.set(id, {
      data,
      timestamp: Date.now()
    });
    console.log(`üì¶ Sourate ${id} mise en cache (${this.memory.surahs.size}/${this.CONFIG.MAX_SURAHS})`);
  },
  
  // R√©cup√©rer du cache
  getSurah(id) {
    const cached = this.memory.surahs.get(id);
    if (cached && (Date.now() - cached.timestamp) < this.CONFIG.CACHE_DURATION) {
      console.log(`‚úÖ Sourate ${id} r√©cup√©r√©e du cache`);
      return cached.data;
    }
    if (cached) {
      this.memory.surahs.delete(id); // Cache expir√©
    }
    return null;
  },
  
  // Gestion du localStorage avec validation
  setLocalStorage(key, data) {
    try {
      const item = {
        data,
        timestamp: Date.now(),
        version: '1.0'
      };
      localStorage.setItem(this.CONFIG.STORAGE_PREFIX + key, JSON.stringify(item));
      return true;
    } catch (error) {
      console.warn('‚ùå Erreur localStorage:', error.message);
      // Nettoyer le localStorage si plein
      this.cleanLocalStorage();
      return false;
    }
  },
  
  // R√©cup√©rer du localStorage avec validation
  getLocalStorage(key, maxAge = this.CONFIG.CACHE_DURATION) {
    try {
      const item = localStorage.getItem(this.CONFIG.STORAGE_PREFIX + key);
      if (!item) return null;
      
      const parsed = JSON.parse(item);
      if (!parsed.timestamp || (Date.now() - parsed.timestamp) > maxAge) {
        localStorage.removeItem(this.CONFIG.STORAGE_PREFIX + key);
        return null;
      }
      
      return parsed.data;
    } catch (error) {
      console.warn('‚ùå Erreur lecture localStorage:', error.message);
      localStorage.removeItem(this.CONFIG.STORAGE_PREFIX + key);
      return null;
    }
  },
  
  // Nettoyer le localStorage
  cleanLocalStorage() {
    const keys = Object.keys(localStorage);
    const prefixedKeys = keys.filter(key => key.startsWith(this.CONFIG.STORAGE_PREFIX));
    
    // Supprimer les entr√©es expir√©es
    prefixedKeys.forEach(key => {
      try {
        const item = JSON.parse(localStorage.getItem(key));
        if (!item.timestamp || (Date.now() - item.timestamp) > this.CONFIG.CACHE_DURATION) {
          localStorage.removeItem(key);
        }
      } catch {
        localStorage.removeItem(key);
      }
    });
    
    console.log(`üßπ Nettoyage localStorage: ${prefixedKeys.length} cl√©s v√©rifi√©es`);
  },
  
  // Obtenir les statistiques du cache
  getStats() {
    return {
      memory: {
        surahs: this.memory.surahs.size,
        audio: this.memory.audio.size,
        hadiths: this.memory.hadiths.size
      },
      localStorage: Object.keys(localStorage).filter(k => k.startsWith(this.CONFIG.STORAGE_PREFIX)).length
    };
  }
};

// Fonctions d'aide pour la navigation dans le menu
window.toggleAudio = function() {
  if (audioPlayerElement.paused) {
    audioPlayerElement.play();
  } else {
    audioPlayerElement.pause();
  }
};

window.nextVerse = function() {
  playNextVerse();
};

window.prevVerse = function() {
  if (audioQueue.length === 0) return;
  
  const currentIndex = audioQueue.indexOf(currentVerse);
  if (currentIndex > 0) {
    playVerseAudio(audioQueue[currentIndex - 1]);
  }
};

// Event Listeners
loadSurahsButton.addEventListener("click", loadSurahs);
searchInput.addEventListener("input", filterSurahs);

// Rempla√ßons l'ancien gestionnaire d'√©v√©nement "ended" par une fonction plus robuste
audioPlayerElement.removeEventListener("ended", onAudioEnded);

// Fonction pour g√©rer la fin de l'audio
function onAudioEnded() {
  console.log("Audio playback ended, switching to preloaded next verse");
  
  // R√©initialiser le flag de pr√©chargement
  isPreloadingNext = false;
  
  if (audioQueue.length === 0) {
    console.log("Audio queue is empty, nothing to play");
    return;
  }
  
  const nextIndex = lastPlayedIndex + 1;
  
  if (nextIndex < audioQueue.length) {
    const nextVerseKey = audioQueue[nextIndex];
    console.log(`Switching to next verse immediately: ${nextVerseKey} (index ${nextIndex}/${audioQueue.length-1})`);
    
    // Maintenir l'√©tat de lecture
    isPlaying = true;
    
    // OPTIMISATION: D√©marrer imm√©diatement la lecture du verset pr√©charg√©
    if (nextAudioElement.readyState >= 3) { // HAVE_FUTURE_DATA ou HAVE_ENOUGH_DATA
      console.log("Using preloaded audio for immediate playback");
      
      // Mettre √† jour les variables de suivi avant la transition
      currentVerse = nextVerseKey;
      lastPlayedIndex = nextIndex;
      
      // CHANGEMENT CL√â: Swap des √©l√©ments audio au lieu de changer la source
      // Ceci √©vite le rechargement et rend la transition instantan√©e
      [audioPlayerElement.src, nextAudioElement.src] = [nextAudioElement.src, ''];
      
      // Mettre √† jour l'UI imm√©diatement
      highlightCurrentVerse(nextVerseKey);
      updateVerseInfo();
      updateMiniPlayer();
      
      // Lancer la lecture imm√©diatement sans d√©lai
      const playPromise = audioPlayerElement.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => {
          console.error("Error during smooth transition:", error);
          // Fallback √† la m√©thode standard en cas d'erreur
          playVerseAudio(nextVerseKey);
        });
      }
      
      // Pr√©charger le verset suivant imm√©diatement
      const futureIndex = nextIndex + 1;
      if (futureIndex < audioQueue.length) {
        preloadVerseAudio(audioQueue[futureIndex], nextAudioElement, true);
      }
    } else {
      // Si le pr√©chargement n'est pas pr√™t, utiliser la m√©thode standard
      console.log("Preloaded audio not ready, using standard playback method");
      playVerseAudio(nextVerseKey);
    }
  } else {
    // Fin de la lecture de la sourate
    console.log("End of surah reached (index", lastPlayedIndex, "of", audioQueue.length - 1, ")");
    isPlaying = false;
    currentTimeElement.textContent = "0:00";
    progressBarElement.style.width = "0%";
    syncPlaybackControls(false);
    updateVerseInfo();
  }
}

// R√©assigner le gestionnaire d'√©v√©nement
audioPlayerElement.addEventListener("ended", onAudioEnded);

audioPlayerElement.addEventListener("timeupdate", updateProgressBar);
audioProgressElement.addEventListener("click", seekAudio);

// Ajout de console.log pour d√©bogage
playButton.addEventListener("click", () => {
  console.log("Play button clicked");
  playAudio();
});

pauseButton.addEventListener("click", () => {
  console.log("Pause button clicked");
  pauseAudio();
});

reciterSelect.addEventListener("change", () => {
  console.log("Reciter changed to:", reciterSelect.value);
  if (currentSurah && currentVerse) {
    // Continuer la lecture √† partir du verset actuel avec le nouveau r√©citateur
    playVerseAudio(currentVerse);
  }
});

// Ajouter les √©couteurs d'√©v√©nements pour les nouveaux contr√¥les
previousVerseButton.addEventListener("click", () => {
  prevVerse();
});

nextVerseButton.addEventListener("click", () => {
  nextVerse();
});

repeatVerseButton.addEventListener("click", () => {
  if (currentVerse) {
    playVerseAudio(currentVerse);
  }
});

volumeSlider.addEventListener("input", () => {
  audioPlayerElement.volume = volumeSlider.value;
});

// Fonction pour synchroniser les contr√¥les de lecture entre les interfaces
function syncPlaybackControls(isPlaying) {
  if (isPlaying) {
    // Mode lecture
    playButton.disabled = true;
    playButtonMain.disabled = true;
    pauseButton.disabled = false;
    pauseButtonMain.style.display = "flex";
    playButtonMain.style.display = "none";
    
    // Activer l'animation equalizer
    equalizerElement.classList.add("active");
    
    // Mini player
    miniPlay.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
    `;
  } else {
    // Mode pause
    playButton.disabled = false;
    playButtonMain.disabled = false;
    pauseButton.disabled = true;
    pauseButtonMain.style.display = "none";
    playButtonMain.style.display = "flex";
    
    // D√©sactiver l'animation equalizer
    equalizerElement.classList.remove("active");
    
    // Mini player
    miniPlay.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="6 3 20 12 6 21 6 3"></polygon>
      </svg>
    `;
  }
}

// Mise √† jour des √©v√©nements pour les boutons principaux
playButtonMain.addEventListener("click", () => {
  console.log("Main play button clicked");
  playAudio();
});

pauseButtonMain.addEventListener("click", () => {
  console.log("Main pause button clicked");
  pauseAudio();
});

// Mini player controls
miniPlay.addEventListener("click", () => {
  if (audioPlayerElement.paused) {
    playAudio();
  } else {
    pauseAudio();
  }
});

// Add event listeners for mini-player's previous and next buttons
miniPrev.addEventListener("click", () => {
  playPreviousVerse();
});

miniNext.addEventListener("click", () => {
  playNextVerse();
});

// Fonction pour mettre √† jour le mini-player
function updateMiniPlayer() {
  if (currentVerse && currentSurah) {
    // Toujours afficher le mini-player
    miniPlayer.classList.add("active");
    
    // Mettre √† jour les informations
    const parts = currentVerse.split(':');
    miniSurahName.textContent = currentSurah.name_simple;
    miniVerseNumber.textContent = `Verset: ${parts[1]}`;
    
    // Mettre √† jour l'√©tat des boutons
    miniPrev.disabled = audioQueue.indexOf(currentVerse) <= 0;
    miniNext.disabled = audioQueue.indexOf(currentVerse) >= audioQueue.length - 1;
  }
  // On ne cache plus le mini-player, il reste toujours visible
}

// Gestionnaire d'erreurs centralis√©
const ErrorHandler = {
  // Types d'erreurs
  TYPES: {
    NETWORK: 'NETWORK',
    TIMEOUT: 'TIMEOUT', 
    HTTP: 'HTTP',
    PARSE: 'PARSE',
    UNKNOWN: 'UNKNOWN'
  },
  
  // Analyser le type d'erreur
  getErrorType(error) {
    if (error.name === 'AbortError') return this.TYPES.TIMEOUT;
    if (error.name === 'TypeError') return this.TYPES.NETWORK;
    if (error.message.includes('HTTP error')) return this.TYPES.HTTP;
    if (error.name === 'SyntaxError') return this.TYPES.PARSE;
    return this.TYPES.UNKNOWN;
  },
  
  // Obtenir un message d'erreur utilisateur
  getUserMessage(error) {
    const type = this.getErrorType(error);
    switch (type) {
      case this.TYPES.TIMEOUT:
        return "D√©lai d'attente d√©pass√©. Veuillez v√©rifier votre connexion.";
      case this.TYPES.NETWORK:
        return "Probl√®me de connexion r√©seau. V√©rifiez votre acc√®s internet.";
      case this.TYPES.HTTP:
        return "Erreur du serveur. Veuillez r√©essayer plus tard.";
      case this.TYPES.PARSE:
        return "Erreur de traitement des donn√©es. Veuillez r√©essayer.";
      default:
        return "Une erreur inattendue s'est produite.";
    }
  },
  
  // Logger l'erreur avec contexte
  log(error, context = '') {
    console.group(`üî¥ Erreur ${context}`);
    console.error('Type:', this.getErrorType(error));
    console.error('Message:', error.message);
    console.error('Stack:', error.stack);
    console.groupEnd();
  }
};

// Fonction fetch am√©lior√©e avec gestion d'erreurs robuste et r√©trocompatibilit√©
async function fetchApi(url, optionsOrRetries = {}, legacyTimeout) {
  // Gestion de la r√©trocompatibilit√© avec l'ancienne signature (url, retries, timeout)
  let options = {};
  if (typeof optionsOrRetries === 'number') {
    options = {
      retries: optionsOrRetries || API_CONFIG.DEFAULT_RETRIES,
      timeout: legacyTimeout || API_CONFIG.DEFAULT_TIMEOUT,
      showUIError: true,
      context: 'legacy call'
    };
  } else {
    options = optionsOrRetries;
  }
  
  const {
    retries = API_CONFIG.DEFAULT_RETRIES,
    timeout = API_CONFIG.DEFAULT_TIMEOUT,
    showUIError = true,
    context = ''
  } = options;
  
  let lastError = null;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      console.log(`üåê Fetching [${attempt + 1}/${retries + 1}]:`, url.substring(0, 100) + '...');
      
      // Contr√¥leur d'abandon pour timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      // Configuration de la requ√™te
      const fetchConfig = {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'PlayOuran/1.0'
        }
      };
      
      const response = await fetch(url, fetchConfig).finally(() => {
        clearTimeout(timeoutId);
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error status: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Succ√®s apr√®s retry
      if (attempt > 0) {
        console.log(`‚úÖ Succ√®s apr√®s ${attempt} tentatives`);
      }
      
      return data;
      
    } catch (error) {
      lastError = error;
      const errorType = ErrorHandler.getErrorType(error);
      
      ErrorHandler.log(error, `${context} (tentative ${attempt + 1})`);
      
      // Pas de retry pour certains types d'erreurs
      if (errorType === ErrorHandler.TYPES.HTTP && error.message.includes('4')) {
        break; // Erreurs 4xx ne doivent pas √™tre retry√©es
      }
      
      // Si ce n'est pas la derni√®re tentative
      if (attempt < retries) {
        // D√©lai exponentiel: 1s, 2s, 4s
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`‚è≥ Retry dans ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // Toutes les tentatives ont √©chou√©
  if (showUIError && quranContentElement) {
    const userMessage = ErrorHandler.getUserMessage(lastError);
    quranContentElement.innerHTML = `
      <div class='error'>
        <p>‚ùå ${userMessage}</p>
        <p><small>Tentatives: ${retries + 1}, URL: ${url.substring(0, 50)}...</small></p>
      </div>
    `;
  }
  
  return null;
}

// API Configuration pour les hadiths authentiques
const HADITH_API_CONFIG = {
  baseUrl: 'https://hadeethenc.com/api/v1',
  language: 'fr', // Fran√ßais pour les traductions
  fallbackLanguage: 'en' // Anglais si fran√ßais non disponible
};

// Cache local pour les hadiths
let hadithCache = {
  categories: [],
  dailyHadith: null,
  lastFetch: null
};

// Collection √©tendue de douas et hadiths avec sources authentiques
const DAILY_DUAS = [
  // Douas du Coran
  {
    arabic: "ÿ±Ÿéÿ®ŸéŸëŸÜŸéÿß ÿ¢ÿ™ŸêŸÜŸéÿß ŸÅŸêŸä ÿßŸÑÿØŸèŸëŸÜŸíŸäŸéÿß ÿ≠Ÿéÿ≥ŸéŸÜŸéÿ©Ÿã ŸàŸéŸÅŸêŸä ÿßŸÑŸíÿ¢ÿÆŸêÿ±Ÿéÿ©Ÿê ÿ≠Ÿéÿ≥ŸéŸÜŸéÿ©Ÿã ŸàŸéŸÇŸêŸÜŸéÿß ÿπŸéÿ∞Ÿéÿßÿ®Ÿé ÿßŸÑŸÜŸéŸëÿßÿ±Ÿê",
    transliteration: "Rabbana atina fid-dunya hasanatan wa fil-akhirati hasanatan waqina 'adhaban-nar",
    traduction: "Notre Seigneur ! Accorde-nous belle part ici-bas et belle part dans l'au-del√†, et pr√©serve-nous du ch√¢timent du Feu.",
    source: "Coran 2:201",
    category: "Invocations coraniques",
    type: "quranic"
  },
  {
    arabic: "ÿ±Ÿéÿ®ŸéŸëŸÜŸéÿß ŸÑŸéÿß ÿ™Ÿèÿ§ŸéÿßÿÆŸêÿ∞ŸíŸÜŸéÿß ÿ•ŸêŸÜ ŸÜŸéŸëÿ≥ŸêŸäŸÜŸéÿß ÿ£ŸéŸàŸí ÿ£ŸéÿÆŸíÿ∑Ÿéÿ£ŸíŸÜŸéÿß",
    transliteration: "Rabbana la tu'akhidhna in nasina aw akhta'na",
    traduction: "Notre Seigneur ! Ne nous ch√¢tie pas s'il nous arrive d'oublier ou de commettre une erreur.",
    source: "Coran 2:286",
    category: "Invocations coraniques",
    type: "quranic"
  },
  {
    arabic: "ÿ±Ÿéÿ®ŸéŸëŸÜŸéÿß ÿßÿ∫ŸíŸÅŸêÿ±Ÿí ŸÑŸêŸä ŸàŸéŸÑŸêŸàŸéÿßŸÑŸêÿØŸéŸäŸéŸë ŸàŸéŸÑŸêŸÑŸíŸÖŸèÿ§ŸíŸÖŸêŸÜŸêŸäŸÜŸé ŸäŸéŸàŸíŸÖŸé ŸäŸéŸÇŸèŸàŸÖŸè ÿßŸÑŸíÿ≠Ÿêÿ≥Ÿéÿßÿ®Ÿè",
    transliteration: "Rabbana-ghfir li wa liwalidayya wa lil mu'minina yawma yaqumu'l hisab",
    traduction: "√î notre Seigneur ! Pardonne-moi, ainsi qu'√† mes p√®re et m√®re et aux croyants, le jour o√π se dressera le compte.",
    source: "Coran 14:41",
    category: "Invocations coraniques",
    type: "quranic"
  },
  {
    arabic: "ÿ±Ÿéÿ®ŸêŸë ÿßÿ¥Ÿíÿ±Ÿéÿ≠Ÿí ŸÑŸêŸä ÿµŸéÿØŸíÿ±ŸêŸä ŸàŸéŸäŸéÿ≥ŸêŸëÿ±Ÿí ŸÑŸêŸä ÿ£ŸéŸÖŸíÿ±ŸêŸä ŸàŸéÿßÿ≠ŸíŸÑŸèŸÑŸí ÿπŸèŸÇŸíÿØŸéÿ©Ÿã ŸÖŸêŸëŸÜ ŸÑŸêŸëÿ≥ŸéÿßŸÜŸêŸä ŸäŸéŸÅŸíŸÇŸéŸáŸèŸàÿß ŸÇŸéŸàŸíŸÑŸêŸä",
    transliteration: "Rabbi-shrah li sadri wa yassir li amri wahlul 'uqdatan min lisani yafqahu qawli",
    traduction: "Seigneur ! Ouvre-moi ma poitrine, facilite ma mission, d√©noue ma langue afin qu'ils comprennent mes paroles.",
    source: "Coran 20:25-28",
    category: "Invocations coraniques",
    type: "quranic"
  },
  {
    arabic: "ÿ±Ÿéÿ®ŸéŸëŸÜŸéÿß ÿ∏ŸéŸÑŸéŸÖŸíŸÜŸéÿß ÿ£ŸéŸÜŸÅŸèÿ≥ŸéŸÜŸéÿß ŸàŸéÿ•ŸêŸÜ ŸÑŸéŸëŸÖŸí ÿ™Ÿéÿ∫ŸíŸÅŸêÿ±Ÿí ŸÑŸéŸÜŸéÿß ŸàŸéÿ™Ÿéÿ±Ÿíÿ≠ŸéŸÖŸíŸÜŸéÿß ŸÑŸéŸÜŸéŸÉŸèŸàŸÜŸéŸÜŸéŸë ŸÖŸêŸÜŸé ÿßŸÑŸíÿÆŸéÿßÿ≥Ÿêÿ±ŸêŸäŸÜŸé",
    transliteration: "Rabbana zalamna anfusana wa il-lam taghfir lana wa tarhamna lanakunanna mina'l-khasirin",
    traduction: "Notre Seigneur ! Nous avons fait du tort √† nous-m√™mes. Et si Tu ne nous pardonnes pas et ne nous fais pas mis√©ricorde, nous serons tr√®s certainement du nombre des perdants.",
    source: "Coran 7:23",
    category: "Invocations coraniques",
    type: "quranic"
  },
  
  // Hadiths authentiques de Sahih al-Bukhari
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿ±Ÿéÿ®ŸéŸëŸÜŸéÿß ÿ¢ÿ™ŸêŸÜŸéÿß ŸÅŸêŸä ÿßŸÑÿØŸèŸëŸÜŸíŸäŸéÿß ÿ≠Ÿéÿ≥ŸéŸÜŸéÿ©Ÿã ŸàŸéŸÅŸêŸä ÿßŸÑÿ¢ÿÆŸêÿ±Ÿéÿ©Ÿê ÿ≠Ÿéÿ≥ŸéŸÜŸéÿ©Ÿã ŸàŸéŸÇŸêŸÜŸéÿß ÿπŸéÿ∞Ÿéÿßÿ®Ÿé ÿßŸÑŸÜŸéŸëÿßÿ±Ÿê",
    transliteration: "Allahumma Rabbana atina fid-dunya hasanatan wa fil-akhirati hasanatan waqina 'adhaban-nar",
    traduction: "√î Allah, notre Seigneur, accorde-nous le meilleur dans ce monde et le meilleur dans l'au-del√†, et prot√®ge-nous du ch√¢timent de l'Enfer.",
    source: "Sahih al-Bukhari 4522, Sahih Muslim 2690",
    category: "Invocations proph√©tiques",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿ•ŸêŸÜŸêŸëŸä ÿ£Ÿéÿ≥Ÿíÿ£ŸéŸÑŸèŸÉŸé ÿßŸÑŸíŸáŸèÿØŸéŸâ ŸàŸéÿßŸÑÿ™ŸèŸëŸÇŸéŸâ ŸàŸéÿßŸÑŸíÿπŸéŸÅŸéÿßŸÅŸé ŸàŸéÿßŸÑŸíÿ∫ŸêŸÜŸéŸâ",
    transliteration: "Allahumma inni as'alukal-huda wat-tuqa wal-'afafa wal-ghina",
    traduction: "√î Allah, je Te demande la guid√©e, la pi√©t√©, la chastet√© et la richesse (spirituelle).",
    source: "Sahih Muslim 2721",
    category: "Invocations proph√©tiques",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿ•ŸêŸÜŸêŸëŸä ÿ£Ÿéÿ≥Ÿíÿ£ŸéŸÑŸèŸÉŸé ÿπŸêŸÑŸíŸÖŸãÿß ŸÜŸéÿßŸÅŸêÿπŸãÿßÿå ŸàŸéÿ±Ÿêÿ≤ŸíŸÇŸãÿß ÿ∑ŸéŸäŸêŸëÿ®Ÿãÿßÿå ŸàŸéÿπŸéŸÖŸéŸÑÿßŸã ŸÖŸèÿ™ŸéŸÇŸéÿ®ŸéŸëŸÑÿßŸã",
    transliteration: "Allahumma inni as'aluka 'ilman nafi'an, wa rizqan tayyiban, wa 'amalan mutaqabbalan",
    traduction: "√î Allah, je Te demande une science b√©n√©fique, une subsistance pure et une ≈ìuvre acceptable.",
    source: "Sunan Ibn Majah 925",
    category: "Invocations proph√©tiques",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿ£ŸéŸÜŸíÿ™Ÿé ÿ±Ÿéÿ®ŸêŸëŸä ŸÑŸéÿß ÿ•ŸêŸÑŸéŸáŸé ÿ•ŸêŸÑŸéŸëÿß ÿ£ŸéŸÜŸíÿ™Ÿéÿå ÿÆŸéŸÑŸéŸÇŸíÿ™ŸéŸÜŸêŸä ŸàŸéÿ£ŸéŸÜŸéÿß ÿπŸéÿ®ŸíÿØŸèŸÉŸéÿå ŸàŸéÿ£ŸéŸÜŸéÿß ÿπŸéŸÑŸéŸâ ÿπŸéŸáŸíÿØŸêŸÉŸé ŸàŸéŸàŸéÿπŸíÿØŸêŸÉŸé ŸÖŸéÿß ÿßÿ≥Ÿíÿ™Ÿéÿ∑ŸéÿπŸíÿ™Ÿèÿå ÿ£ŸéÿπŸèŸàÿ∞Ÿè ÿ®ŸêŸÉŸé ŸÖŸêŸÜŸí ÿ¥Ÿéÿ±ŸêŸë ŸÖŸéÿß ÿµŸéŸÜŸéÿπŸíÿ™Ÿèÿå ÿ£Ÿéÿ®ŸèŸàÿ°Ÿè ŸÑŸéŸÉŸé ÿ®ŸêŸÜŸêÿπŸíŸÖŸéÿ™ŸêŸÉŸé ÿπŸéŸÑŸéŸäŸéŸëÿå ŸàŸéÿ£Ÿéÿ®ŸèŸàÿ°Ÿè ÿ®Ÿêÿ∞ŸéŸÜŸíÿ®ŸêŸä ŸÅŸéÿßÿ∫ŸíŸÅŸêÿ±Ÿí ŸÑŸêŸä ŸÅŸéÿ•ŸêŸÜŸéŸëŸáŸè ŸÑŸéÿß ŸäŸéÿ∫ŸíŸÅŸêÿ±Ÿè ÿßŸÑÿ∞ŸèŸëŸÜŸèŸàÿ®Ÿé ÿ•ŸêŸÑŸéŸëÿß ÿ£ŸéŸÜŸíÿ™Ÿé",
    transliteration: "Allahumma anta Rabbi la ilaha illa anta, khalaqtani wa ana 'abduka, wa ana 'ala 'ahdika wa wa'dika mastata'tu, a'udhu bika min sharri ma sana'tu, abu'u laka bini'matika 'alayya, wa abu'u bidhanbi faghfirli fa innahu la yaghfirudh-dhunuba illa anta",
    traduction: "√î Allah ! Tu es mon Seigneur, il n'y a point de divinit√© en dehors de Toi. Tu m'as cr√©√© et je suis Ton serviteur. Je respecte autant que possible mon engagement et ma promesse envers Toi. Je cherche refuge aupr√®s de Toi contre le mal que j'ai commis. Je reconnais Ton bienfait √† mon √©gard et je reconnais mon p√©ch√©. Pardonne-moi car nul autre que Toi ne pardonne les p√©ch√©s.",
    source: "Sahih al-Bukhari 6306",
    category: "Sayyid al-Istighfar (Ma√Ætre de la demande de pardon)",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  
  // Hadiths de Sahih Muslim
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿ£ŸéÿπŸêŸÜŸêŸëŸä ÿπŸéŸÑŸéŸâ ÿ∞ŸêŸÉŸíÿ±ŸêŸÉŸé ŸàŸéÿ¥ŸèŸÉŸíÿ±ŸêŸÉŸé ŸàŸéÿ≠Ÿèÿ≥ŸíŸÜŸê ÿπŸêÿ®ŸéÿßÿØŸéÿ™ŸêŸÉŸé",
    transliteration: "Allahumma a'inni 'ala dhikrika wa shukrika wa husni 'ibadatika",
    traduction: "√î Allah, aide-moi √† T'invoquer, √† Te remercier et √† bien T'adorer.",
    source: "Sahih Muslim, Abu Dawud 1522",
    category: "Invocations proph√©tiques",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  {
    arabic: "ÿßŸÑŸÑŸéŸëŸáŸèŸÖŸéŸë ÿßÿ∫ŸíŸÅŸêÿ±Ÿí ŸÑŸêŸä ÿ∞ŸéŸÜŸíÿ®ŸêŸä ŸàŸéŸàŸéÿ≥ŸêŸëÿπŸí ŸÑŸêŸä ŸÅŸêŸä ÿØŸéÿßÿ±ŸêŸä ŸàŸéÿ®Ÿéÿßÿ±ŸêŸÉŸí ŸÑŸêŸä ŸÅŸêŸäŸÖŸéÿß ÿ±Ÿéÿ≤ŸéŸÇŸíÿ™ŸéŸÜŸêŸä",
    transliteration: "Allahumma-ghfir li dhanbi wa wassi' li fi dari wa barik li fima razaqtani",
    traduction: "√î Allah, pardonne-moi mes p√©ch√©s, √©largis ma demeure et b√©nis ce que Tu m'as accord√© comme subsistance.",
    source: "Sahih Muslim, Al-Tirmidhi 3500",
    category: "Invocations proph√©tiques",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  
  // Hadiths sur les vertus
  {
    arabic: "ŸÖŸéŸÜŸí ŸÇŸéÿßŸÑŸé ŸÑŸéÿß ÿ•ŸêŸÑŸéŸáŸé ÿ•ŸêŸÑŸéŸëÿß ÿßŸÑŸÑŸéŸëŸáŸè ŸàŸéÿ≠ŸíÿØŸéŸáŸè ŸÑŸéÿß ÿ¥Ÿéÿ±ŸêŸäŸÉŸé ŸÑŸéŸáŸèÿå ŸÑŸéŸáŸè ÿßŸÑŸíŸÖŸèŸÑŸíŸÉŸè ŸàŸéŸÑŸéŸáŸè ÿßŸÑŸíÿ≠ŸéŸÖŸíÿØŸè ŸàŸéŸáŸèŸàŸé ÿπŸéŸÑŸéŸâ ŸÉŸèŸÑŸêŸë ÿ¥ŸéŸäŸíÿ°Ÿç ŸÇŸéÿØŸêŸäÿ±Ÿåÿå ŸÅŸêŸä ŸäŸéŸàŸíŸÖŸç ŸÖŸêÿßÿ¶Ÿéÿ©Ÿé ŸÖŸéÿ±ŸéŸëÿ©Ÿç ŸÉŸéÿßŸÜŸéÿ™Ÿí ŸÑŸéŸáŸè ÿπŸéÿØŸíŸÑŸé ÿπŸéÿ¥Ÿíÿ±Ÿê ÿ±ŸêŸÇŸéÿßÿ®Ÿç",
    transliteration: "Man qala la ilaha illa Allah wahdahu la sharika lahu, lahu'l-mulku wa lahu'l-hamd wa huwa 'ala kulli shay'in qadir, fi yawmin mi'ata marrah kanat lahu 'adlu 'ashri riqab",
    traduction: "Quiconque dit cent fois par jour : 'Il n'y a de divinit√© qu'Allah, Seul, sans associ√©. √Ä Lui la royaut√©, √† Lui la louange et Il est capable de toute chose', cela √©quivaut pour lui √† l'affranchissement de dix esclaves.",
    source: "Sahih al-Bukhari 3293, Sahih Muslim 2691",
    category: "Dhikr et ses m√©rites",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  },
  
  // Invocations du matin et du soir
  {
    arabic: "ÿ£ŸéÿµŸíÿ®Ÿéÿ≠ŸíŸÜŸéÿß ŸàŸéÿ£ŸéÿµŸíÿ®Ÿéÿ≠Ÿé ÿßŸÑŸíŸÖŸèŸÑŸíŸÉŸè ŸÑŸêŸÑŸéŸëŸáŸêÿå ŸàŸéÿßŸÑŸíÿ≠ŸéŸÖŸíÿØŸè ŸÑŸêŸÑŸéŸëŸáŸêÿå ŸÑŸéÿß ÿ•ŸêŸÑŸéŸáŸé ÿ•ŸêŸÑŸéŸëÿß ÿßŸÑŸÑŸéŸëŸáŸè ŸàŸéÿ≠ŸíÿØŸéŸáŸè ŸÑŸéÿß ÿ¥Ÿéÿ±ŸêŸäŸÉŸé ŸÑŸéŸáŸè",
    transliteration: "Asbahna wa asbahal-mulku lillah, wal-hamdu lillah, la ilaha illa Allah wahdahu la sharika lah",
    traduction: "Nous voici au matin et le royaume appartient √† Allah, la louange est √† Allah, il n'y a de divinit√© qu'Allah, Seul, sans associ√©.",
    source: "Sahih Muslim 2723",
    category: "Adhkar du matin",
    type: "hadith",
    authenticity: "Sahih (Authentique)"
  }
];

// Fonction pour r√©cup√©rer des hadiths depuis l'API HadeethEnc.com
async function fetchHadithFromAPI() {
  try {
    console.log('Tentative de r√©cup√©ration de hadith depuis l\'API...');
    
    // R√©cup√©rer d'abord les cat√©gories
    const categoriesResponse = await fetch(`${HADITH_API_CONFIG.baseUrl}/categories/roots/?language=${HADITH_API_CONFIG.language}`);
    if (!categoriesResponse.ok) {
      throw new Error('√âchec de r√©cup√©ration des cat√©gories');
    }
    
    const categories = await categoriesResponse.json();
    hadithCache.categories = categories;
    
    // Choisir une cat√©gorie al√©atoire (ex: Vertus et Mani√®res)
    const randomCategory = categories[Math.floor(Math.random() * categories.length)];
    
    // R√©cup√©rer les hadiths de cette cat√©gorie
    const hadithsResponse = await fetch(`${HADITH_API_CONFIG.baseUrl}/hadeeths/list/?language=${HADITH_API_CONFIG.language}&category_id=${randomCategory.id}&page=1&per_page=20`);
    
    if (!hadithsResponse.ok) {
      throw new Error('√âchec de r√©cup√©ration des hadiths');
    }
    
    const hadithsData = await hadithsResponse.json();
    
    if (hadithsData.data && hadithsData.data.length > 0) {
      // Choisir un hadith al√©atoire
      const randomHadith = hadithsData.data[Math.floor(Math.random() * hadithsData.data.length)];
      
      // R√©cup√©rer les d√©tails complets du hadith
      const hadithDetailResponse = await fetch(`${HADITH_API_CONFIG.baseUrl}/hadeeths/one/?language=${HADITH_API_CONFIG.language}&id=${randomHadith.id}`);
      
      if (hadithDetailResponse.ok) {
        const hadithDetail = await hadithDetailResponse.json();
        
        return {
          arabic: hadithDetail.hadeeth || randomHadith.title,
          transliteration: "", // L'API ne fournit pas toujours la translitt√©ration
          traduction: hadithDetail.explanation || randomHadith.title,
          source: `HadeethEnc.com - ${randomCategory.title}`,
          category: randomCategory.title,
          type: "hadith",
          authenticity: hadithDetail.grade || "Authentique",
          apiSource: true
        };
      }
    }
  } catch (error) {
    console.warn('Erreur lors de la r√©cup√©ration depuis l\'API:', error);
  }
  
  // Retourner null si l'API √©choue
  return null;
}

// Obtenir une doua al√©atoire ou celle du jour si d√©j√† sauvegard√©e
async function getRandomDua() {
  try {
    const savedDua = JSON.parse(localStorage.getItem('dailyDua') || '{}');
    const now = new Date();
    const today = now.toISOString().split('T')[0]; // Format YYYY-MM-DD
    
    // Si nous avons une doua sauvegard√©e pour aujourd'hui, l'utiliser
    if (savedDua.date === today && savedDua.dua) {
      return savedDua.dua;
    }
    
    // Essayer d'abord de r√©cup√©rer depuis l'API (20% de chance pour avoir de la vari√©t√©)
    if (Math.random() < 0.2) {
      const apiHadith = await fetchHadithFromAPI();
      if (apiHadith) {
        // Sauvegarder le hadith de l'API pour aujourd'hui
        localStorage.setItem('dailyDua', JSON.stringify({
          date: today,
          dua: apiHadith
        }));
        return apiHadith;
      }
    }
    
    // Sinon, utiliser la collection locale
    const randomIndex = Math.floor(Math.random() * DAILY_DUAS.length);
    const dua = DAILY_DUAS[randomIndex];
    
    // Sauvegarder la doua du jour
    localStorage.setItem('dailyDua', JSON.stringify({
      date: today,
      dua: dua
    }));
    
    return dua;
  } catch (e) {
    console.error("Erreur lors de la r√©cup√©ration/sauvegarde de la doua du jour:", e);
    // En cas d'erreur, simplement retourner une doua al√©atoire sans sauvegarder
    const randomIndex = Math.floor(Math.random() * DAILY_DUAS.length);
    return DAILY_DUAS[randomIndex];
  }
}

// Mettre √† jour le message de bienvenue pour indiquer que les sourates sont charg√©es
async function updateWelcomeMessage() {
  const currentDate = new Date();
  const formattedDate = new Intl.DateTimeFormat('fr-FR', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  }).format(currentDate);

  // Obtenir une doua al√©atoire
  const randomDua = await getRandomDua();
  
  // Formater la source de fa√ßon plus explicite
  let sourceText = randomDua.source;
  if (sourceText.startsWith("Coran")) {
    // Extraire les num√©ros de sourate et verset
    const parts = sourceText.split(":");
    if (parts.length === 2) {
      const sourate = parts[0].replace("Coran ", "");
      const verset = parts[1];
      sourceText = `Sourate ${sourate}, Verset ${verset}`;
    }
  }

  quranContentElement.innerHTML = `
    <div class="welcome-screen">
      <div class="welcome-header">
        <h2 class="welcome-title animated-welcome">Bienvenue</h2>
        <p class="welcome-date">${formattedDate}</p>
      </div>

      <!-- Invocation du jour en position strat√©gique, avant le contenu principal -->
      <div class="dua-of-the-day">
        <div class="dua-header">
          ${randomDua.category ? `<span class="dua-category">${randomDua.category}</span>` : ''}
        </div>
        <div class="dua-content">
          <div class="dua-arabic-container">
            <p class="dua-arabic">${cleanArabicText(randomDua.arabic)}</p>
          </div>
          ${randomDua.transliteration ? `
            <div class="dua-transliteration-container">
              <p class="dua-transliteration">${randomDua.transliteration}</p>
            </div>
          ` : ''}
          <div class="dua-translation-container">
            <p class="dua-translation">${randomDua.traduction}</p>
          </div>
          <div class="dua-source-container">
            <span class="dua-source">${sourceText}</span>
            ${randomDua.authenticity ? `<span class="dua-authenticity">${randomDua.authenticity}</span>` : ''}
          </div>
        </div>
      </div>

      <div class="welcome-content">
        <div class="welcome-icon animated">
          <svg xmlns="http://www.w3.org/2000/svg" width="120" height="120" viewBox="0 0 24 24" fill="none" stroke="#0071e3" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="book-icon">
            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            <path class="book-page" d="M12 6l8 0"></path>
            <path class="book-page" d="M12 10l8 0"></path>
            <path class="book-page" d="M12 14l8 0"></path>
          </svg>
        </div>

        <div class="welcome-text-container">
          <p class="welcome-text">S√©lectionnez une sourate dans la liste ci-dessus pour commencer votre lecture</p>
          
          <div class="welcome-stats">
            <div class="stat-item">
              <span class="stat-value">${allSurahs.length}</span>
              <span class="stat-label">Sourates</span>
            </div>
            <div class="stat-item">
              <span class="stat-value">6236</span>
              <span class="stat-label">Versets</span>
            </div>
            <div class="stat-item">
              <span class="stat-value">${RECITERS.length}</span>
              <span class="stat-label">R√©citateurs</span>
            </div>
          </div>
          
          <div class="welcome-tips">
            <p><strong>Astuce :</strong> Utilisez la barre de recherche pour trouver rapidement une sourate</p>
            <p><strong>Nouveau :</strong> √âcoutez les r√©citations en fran√ßais avec Youssouf Leclerc</p>
          </div>
        </div>
      </div>

      <div class="welcome-footer">
        <div class="last-read">
          <h3>Derni√®re lecture</h3>
          <p id="last-read-info">Aucune lecture r√©cente</p>
          <button id="resume-reading" class="resume-button" disabled>Reprendre la lecture</button>
        </div>
      </div>
    </div>
  `;

  // R√©cup√©rer la derni√®re sourate lue dans localStorage
  try {
    const lastReadData = JSON.parse(localStorage.getItem('lastRead') || '{}');
    if (lastReadData.surahId) {
      const surah = allSurahs.find(s => s.id === parseInt(lastReadData.surahId));
      if (surah) {
        const lastReadInfo = document.getElementById('last-read-info');
        const resumeButton = document.getElementById('resume-reading');
        
        lastReadInfo.textContent = `Sourate ${surah.id}: ${surah.name_simple} (${surah.translated_name.name})`;
        resumeButton.disabled = false;
        
        // Ajouter un event listener pour reprendre la lecture
        resumeButton.addEventListener('click', () => {
          const surahElement = document.querySelector(`.surah-item[data-id="${surah.id}"]`);
          if (surahElement) {
            surahElement.click();
          }
        });
      }
    }
  } catch (e) {
    console.error("Erreur lors de la r√©cup√©ration de la derni√®re lecture:", e);
  }
}

// Load list of Surahs
async function loadSurahs() {
  quranContentElement.innerHTML = "<div class='loading'>Chargement des sourates...</div>";
  
  // We will use the Quran.com API to get surah list
  const data = await fetchApi(QURAN_API_URL + "api/v4/chapters?language=fr", { 
    context: 'liste des sourates'
  });
  
  if (!data) return;
  
  allSurahs = data.chapters;
  displaySurahs(allSurahs);
  
  // Mettre √† jour les options de r√©citateurs
  updateReciterOptions();
  
  // Mettre √† jour les options de traduction
  updateTranslationOptions();
  
  // Afficher le message de bienvenue
  await updateWelcomeMessage();
  
  // Sauvegarder dans localStorage pour charger plus rapidement la prochaine fois
  localStorage.setItem('allSurahs', JSON.stringify(allSurahs));
}

// Display surahs in the sidebar
function displaySurahs(surahs) {
  surahListElement.innerHTML = "";
  
  surahs.forEach((surah, index) => {
    const surahElement = document.createElement("div");
    surahElement.className = "surah-item";
    surahElement.dataset.id = surah.id;
    // Add animation delay based on index
    surahElement.style.setProperty('--item-index', index);
    
    // Check if this is the currently selected surah
    if (currentSurah && surah.id === currentSurah.id) {
      surahElement.classList.add("active");
      // Ajouter une classe √† la sidebar pour indiquer qu'une sourate est active
      document.querySelector('.sidebar').classList.add('has-active-surah');
    }
    
    // Create surah number element
    const surahNumber = document.createElement("div");
    surahNumber.className = "surah-item-number";
    surahNumber.textContent = surah.id;
    
    // Create surah name element
    const surahName = document.createElement("div");
    surahName.className = "surah-item-name";
    surahName.textContent = surah.name_simple;
    
    // Create surah translation element
    const surahTranslation = document.createElement("div");
    surahTranslation.className = "surah-item-translation";
    surahTranslation.textContent = surah.translated_name.name;
    
    // Create verses count element
    const surahVerses = document.createElement("div");
    surahVerses.className = "surah-item-verses";
    surahVerses.textContent = `${surah.verses_count} versets`;
    
    // Add elements to surah item
    surahElement.appendChild(surahNumber);
    surahElement.appendChild(surahName);
    surahElement.appendChild(surahTranslation);
    surahElement.appendChild(surahVerses);
    
    surahElement.addEventListener("click", () => {
      // R√©initialiser les variables de lecture
      audioPlayerElement.pause();
      audioPlayerElement.currentTime = 0;
      currentVerse = null;
      audioQueue = [];
      lastPlayedIndex = -1;
      isPlaying = false;
      
      // Remove active class from all surah items
      document.querySelectorAll(".surah-item").forEach(item => {
        item.classList.remove("active");
      });
      // Add active class to clicked surah item
      surahElement.classList.add("active");
      
      // Ajouter une classe √† la sidebar pour indiquer qu'une sourate est active
      document.querySelector('.sidebar').classList.add('has-active-surah');
      
      // Afficher un effet de surbrillance temporaire
      surahElement.classList.add("just-selected");
      setTimeout(() => {
        surahElement.classList.remove("just-selected");
      }, 1000);
      
      // Scroll to make sure the selected surah is visible
      surahElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      
      loadSurah(surah.id);
    });
    surahListElement.appendChild(surahElement);
  });
  
  // Apr√®s avoir affich√© toutes les sourates, scroll vers la sourate active si elle existe
  setTimeout(() => {
    const activeSurah = document.querySelector('.surah-item.active');
    if (activeSurah) {
      activeSurah.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }, 100);
}

// Filter surahs based on search input with improved search capabilities
function filterSurahs() {
  const searchTerm = searchInput.value.trim().toLowerCase();
  
  if (!searchTerm) {
    displaySurahs(allSurahs);
    return;
  }
  
  // Normalize for accents and special characters
  const normalizeText = (text) => {
    return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
  };
  
  const normalizedSearch = normalizeText(searchTerm);
  
  // Match function that checks if term is found in text
  const matches = (text, term) => {
    if (!text) return false;
    // Check original text
    if (text.toLowerCase().includes(term)) return true;
    // Check normalized text (no accents)
    const normalizedText = normalizeText(text);
    return normalizedText.includes(term);
  };

  // Function to get match score (higher is better match)
  const getMatchScore = (surah, term) => {
    let score = 0;
    
    // Exact number match is highest priority
    if (surah.id.toString() === term) {
      return 100;
    }
    
    // Name starts with term is high priority
    if (surah.name_simple.toLowerCase().startsWith(term)) {
      score += 50;
    }
    
    // Name contains term
    if (matches(surah.name_simple, term)) {
      score += 30;
    }
    
    // Translation starts with term
    if (surah.translated_name.name.toLowerCase().startsWith(term)) {
      score += 40;
    }
    
    // Translation contains term
    if (matches(surah.translated_name.name, term)) {
      score += 20;
    }
    
    // Number contains term (partial match)
    if (surah.id.toString().includes(term)) {
      score += 15;
    }
    
    return score;
  };

  // Filter and sort by relevance
  const filteredSurahs = allSurahs
    .map(surah => {
      const score = getMatchScore(surah, normalizedSearch);
      return { surah, score };
    })
    .filter(item => {
      return item.score > 0 || (currentSurah && item.surah.id === currentSurah.id);
    })
    .sort((a, b) => b.score - a.score)
    .map(item => item.surah);
  
  // Always include current surah
  if (currentSurah && !filteredSurahs.some(surah => surah.id === currentSurah.id)) {
    filteredSurahs.push(currentSurah);
  }
  
  displaySurahs(filteredSurahs);
}

// Load Surah content
async function loadSurah(surahId) {
  // Reset current verse
  currentVerse = null;
  audioQueue = [];
  
  // Show loading indicator without removing the surah list
  quranContentElement.innerHTML = "<div class='loading'>Chargement de la sourate...</div>";
  
  // Get surah info
  const surah = allSurahs.find(s => s.id === parseInt(surahId));
  currentSurah = surah;
  
  // Sauvegarder la derni√®re sourate consult√©e dans localStorage
  try {
    localStorage.setItem('lastRead', JSON.stringify({
      surahId: surah.id,
      timestamp: new Date().toISOString()
    }));
  } catch (e) {
    console.error("Erreur lors de la sauvegarde de la derni√®re lecture:", e);
  }
  
  // Vider le cache pour cette sourate lorsque la traduction change
  delete surahCache[surahId];
  
  // V√©rifier si la sourate est d√©j√† dans le cache
  if (surahCache[surahId]) {
    console.log(`Chargement de la sourate ${surahId} depuis le cache`);
    displaySurahContent(surah, surahCache[surahId]);
    return;
  }
  
  // Prepare to store all verses
  let allVerses = [];
  
  // Calculate how many pages we need to fetch based on verse count
  // API has a limit of 50 verses per page, but we'll request max of 100 to minimize requests
  const perPage = 100;
  const totalPages = Math.ceil(surah.verses_count / perPage);
  
  // Update loading message to show that we're fetching multiple pages
  if (totalPages > 1) {
    quranContentElement.innerHTML = `<div class='loading'>Chargement de la sourate (${surah.verses_count} versets)...<br>Page 1 sur ${totalPages}</div>`;
  }
  
  // Get the selected translation
  const translationId = translationSelect.value || '31';
  
  // Fetch all pages of verses
  for (let page = 1; page <= totalPages; page++) {
    if (page > 1) {
      // Update loading message to show progress
      quranContentElement.innerHTML = `<div class='loading'>Chargement de la sourate (${surah.verses_count} versets)...<br>Page ${page} sur ${totalPages}</div>`;
    }
    
    const url = `${QURAN_API_URL}api/v4/verses/by_chapter/${surahId}?language=fr&translations=${translationId}&fields=text_indopak,chapter_id,verse_number,verse_key,translations&per_page=${perPage}&page=${page}`;
    const data = await fetchApi(url, { 
      context: `versets sourate ${surahId} page ${page}`
    });
    
    if (!data) {
      quranContentElement.innerHTML = "<div class='error'>Erreur lors du chargement des versets. Veuillez r√©essayer.</div>";
      return;
    }
    
    // Add this page's verses to our collection
    allVerses = allVerses.concat(data.verses);
  }
  
  // Mettre la sourate dans le cache
  surahCache[surahId] = allVerses;
  
  // Sauvegarder les sourates r√©cemment consult√©es dans localStorage
  try {
    const recentSurahs = JSON.parse(localStorage.getItem('recentSurahs') || '{}');
    // Limiter √† 3 sourates dans le cache local pour √©viter de surcharger localStorage
    const recentSurahIds = Object.keys(recentSurahs);
    if (recentSurahIds.length >= 3) {
      delete recentSurahs[recentSurahIds[0]]; // Supprimer la plus ancienne sourate
    }
    recentSurahs[surahId] = allVerses;
    localStorage.setItem('recentSurahs', JSON.stringify(recentSurahs));
  } catch (e) {
    console.error("Erreur lors de la sauvegarde dans localStorage:", e);
  }
  
  // Afficher le contenu
  displaySurahContent(surah, allVerses);
}

// Fonction pour nettoyer le texte de traduction des balises HTML non souhait√©es
function cleanTranslationText(text) {
  if (!text) return "";
  
  // Supprimer les balises sup avec leur contenu
  return text.replace(/<sup[^>]*>.*?<\/sup>/g, '')
             // Autres nettoyages possibles
             .replace(/&lt;/g, '<')
             .replace(/&gt;/g, '>')
             .replace(/&quot;/g, '"')
             .replace(/&apos;/g, "'")
             .replace(/&amp;/g, '&')
             .trim();
}

// Fonction pour nettoyer le texte arabe des caract√®res sp√©ciaux qui peuvent causer des probl√®mes d'affichage
function cleanArabicText(text) {
  if (!text) return "";
  
  // Utiliser une m√©thode plus robuste pour nettoyer les caract√®res carr√©s et probl√©matiques
  // Remplacer chaque caract√®re non-affichable ou carr√© par une cha√Æne vide
  const cleanedText = text.replace(/[\u25A0-\u25FF\u2610-\u261B\u2B1B\u2B1C\u25FB-\u25FE]/g, '')
                        .replace(/[\u0000-\u001F\u007F-\u009F\u2500-\u257F]/g, '')
                        .replace(/[\uFFF0-\uFFFF]/g, '')
                        // Remplacer les caract√®res de ponctuation sp√©cifiques du Coran s'ils posent probl√®me
                        .replace(/\u06DD/g, '') // End of ayah
                        .replace(/\u06DE/g, '') // Start of rub el hizb
                        .replace(/\u06E9/g, '') // Place of sajdah
                        .replace(/\u06D6/g, '') // End of sajdah
                        .replace(/\u06D7/g, '') // End of quran
                        // Supprimer les caract√®res invisibles, mais pr√©server certains
                        .replace(/[\u200B-\u200F\u202A-\u202E\u2060-\u2064]/g, '')
                        .trim();
                        
  // Si le r√©sultat contient encore des caract√®res carr√©s visibles, on utilisera une m√©thode plus agressive
  if (/[\u25A0-\u25FF\u2610-\u261B]/.test(cleanedText)) {
    console.log("Des caract√®res carr√©s persistent, application d'un nettoyage suppl√©mentaire");
    
    // Essayer de remplacer les caract√®res probl√©matiques par les caract√®res √©quivalents corrects
    return cleanedText.replace(/\u25A0|\u25A1|\u25FB|\u25FC|\u2610|\u2611|\u2612/g, ' ');
  }
  
  return cleanedText;
}

// Fonction pour encoder le texte pour utilisation avec innerHTML
function encodeHTMLEntities(text) {
  const textArea = document.createElement('textarea');
  textArea.textContent = text;
  return textArea.innerHTML;
}

// Modification de la fonction displaySurahContent pour utiliser une source alternative pour le texte arabe si n√©cessaire
async function displaySurahContent(surah, verses) {
  // Update surah info with Apple style formatting
  surahInfoElement.innerHTML = `
    <h2>${surah.name_simple}</h2>
    <div class="meta">
      <span>${surah.translated_name.name}</span>
      <span>${surah.verses_count} versets</span>
    </div>
    <div class="selected-surah-indicator">Sourate ${surah.id}</div>
  `;
  
  // Clear content
  quranContentElement.innerHTML = "";
  
  // Add bismillah if needed
  if (surah.id !== 1 && surah.id !== 9) {
    const bismillah = document.createElement("div");
    bismillah.className = "verse-container bismillah";
    
    const bismillahText = document.createElement("div");
    bismillahText.className = "verse-text";
    bismillahText.textContent = "ÿ®Ÿêÿ≥ŸíŸÖŸê ÿßŸÑŸÑŸëŸ∞ŸáŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸíŸÖŸ∞ŸÜŸê ÿßŸÑÿ±ŸéŸëÿ≠ŸêŸäŸíŸÖŸê";
    bismillah.appendChild(bismillahText);
    
    quranContentElement.appendChild(bismillah);
  }
  
  // Fetch an alternative text source for Arabic text if needed
  let alternativeArabicText = {};
  try {
    // Utiliser l'API alquran.cloud pour obtenir le texte arabe sans caract√®res sp√©ciaux probl√©matiques
    const response = await fetch(`https://api.alquran.cloud/v1/surah/${surah.id}/ar.asad`);
    const data = await response.json();
    
    if (data.code === 200 && data.data && data.data.ayahs) {
      data.data.ayahs.forEach(ayah => {
        alternativeArabicText[ayah.numberInSurah] = ayah.text;
      });
      console.log(`Texte arabe alternatif charg√© pour la sourate ${surah.id}`);
    }
  } catch (error) {
    console.error("Erreur lors du chargement du texte arabe alternatif:", error);
  }
  
  // Add verse by verse with French translation
  verses.forEach(verse => {
    const verseKey = `${surah.id}:${verse.verse_number}`;
    const verseContainer = document.createElement("div");
    verseContainer.className = "verse-container";
    verseContainer.id = `verse-${verseKey}`;
    
    // Cr√©er l'en-t√™te du verset avec le num√©ro
    const verseHeader = document.createElement("div");
    verseHeader.className = "verse-header";
    
    const verseNumber = document.createElement("div");
    verseNumber.className = "verse-number";
    verseNumber.textContent = verse.verse_number;
    
    // Bouton audio avec ic√¥ne SVG int√©gr√©e
    const audioButton = document.createElement("button");
    audioButton.className = "verse-audio-button";
    audioButton.dataset.verseKey = verseKey;
    audioButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    `;
    
    audioButton.addEventListener("click", () => {
      playVerseAudio(verseKey);
    });
    
    verseHeader.appendChild(verseNumber);
    verseHeader.appendChild(audioButton);
    verseContainer.appendChild(verseHeader);
    
    // Arabic text with enhanced rendering and fallback
    const verseText = document.createElement("div");
    verseText.className = "verse-text";
    
    // Prioritize alternative source if available, otherwise clean the existing text
    let arabicText = "";
    if (alternativeArabicText[verse.verse_number]) {
      arabicText = alternativeArabicText[verse.verse_number];
      console.log(`Utilisation du texte alternatif pour le verset ${verse.verse_number}`);
    } else {
      // Nettoyer le texte arabe des caract√®res sp√©ciaux qui peuvent √™tre mal rendus
      arabicText = cleanArabicText(verse.text_indopak);
    }
    
    // Utiliser innerHTML pour un meilleur rendu des caract√®res sp√©ciaux
    verseText.innerHTML = encodeHTMLEntities(arabicText);
    
    verseContainer.appendChild(verseText);
    
    // V√©rifier si l'option "Sans traduction" est s√©lectionn√©e
    const selectedTranslation = translationSelect.value;
    if (selectedTranslation !== 'none') {
      // Translation
      const translation = document.createElement("div");
      translation.className = "verse-translation";
      
      // Get translation if available
      let translationText = "Traduction non disponible";
      if (verse.translations && verse.translations.length > 0) {
        translationText = verse.translations[0].text;
        
        // Nettoyer les balises HTML dans le texte de la traduction
        translationText = cleanTranslationText(translationText);
      }
      
      translation.textContent = translationText;
      verseContainer.appendChild(translation);
    }
    
    // Add to content
    quranContentElement.appendChild(verseContainer);
    
    // Add to audio queue
    audioQueue.push(verseKey);
  });
  
  // Enable audio controls
  playButton.disabled = false;
  pauseButton.disabled = false;
  
  // Update control buttons state
  updateControlButtons();
  
  // V√©rifier si une banni√®re existe d√©j√† et la supprimer le cas √©ch√©ant
  const existingBanner = quranContentElement.querySelector('.selected-surah-banner');
  if (existingBanner) {
    existingBanner.remove();
  }
  
  // Ajouter un bandeau indicateur en haut du contenu
  const selectedSurahBanner = document.createElement("div");
  selectedSurahBanner.className = "selected-surah-banner";
  selectedSurahBanner.innerHTML = `
    <div class="banner-content">
      <div class="banner-icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
          <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
        </svg>
      </div>
      <div class="banner-text">
        <strong>Sourate actuelle : ${surah.name_simple}</strong>
        <span>${surah.translated_name.name} - ${surah.verses_count} versets</span>
      </div>
    </div>
  `;
  quranContentElement.insertBefore(selectedSurahBanner, quranContentElement.firstChild);
  
  // On v√©rifie quand m√™me la disponibilit√© hors ligne (pour d'autres fonctionnalit√©s)
  checkOfflineAvailability(surah.id);
}

// Formater le num√©ro de verset pour l'URL audio (avec leading zeros)
function formatVerseNumber(verse) {
  const parts = verse.split(':');
  const surahNumber = parts[0].padStart(3, '0');
  const verseNumber = parts[1].padStart(3, '0');
  return { surahNumber, verseNumber };
}

// Play audio for a specific verse using Alquran.cloud API
function playVerseAudio(verseKey) {
  // V√©rification plus stricte pour √©viter la double lecture
  if (currentVerse === verseKey && !audioPlayerElement.paused && audioPlayerElement.currentTime > 0) {
    console.log("Ce verset est d√©j√† en cours de lecture:", verseKey);
    return;
  }
  
  // Arr√™ter l'animation de highlight sans arr√™ter l'audio
  if (highlightInterval) {
    clearInterval(highlightInterval);
    highlightInterval = null;
  }
  
  // Mise √† jour de lastPlayedIndex pour le suivi de la s√©quence
  if (audioQueue.includes(verseKey)) {
    lastPlayedIndex = audioQueue.indexOf(verseKey);
    console.log(`Tracking verse index: ${lastPlayedIndex} of ${audioQueue.length - 1}`);
    
    // OPTIMISATION: Pr√©charger imm√©diatement les 2 versets suivants
    preloadFutureVerses(lastPlayedIndex);
  }
  
  // Mettre √† jour l'UI pour montrer que la lecture est en cours
  document.querySelectorAll(".verse-container").forEach(container => {
    container.classList.remove("active");
  });
  
  // V√©rifier si le verset est disponible hors ligne
  const parts = verseKey.split(':');
  const surahId = parts[0];
  const verseNum = parts[1];
  let audioUrl = null;
  let isOffline = false;
  
  try {
    // V√©rifier dans le localStorage si la sourate est disponible hors ligne
    const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
    if (offlineAudio[surahId]) {
      // Chercher le verset correspondant
      const verset = offlineAudio[surahId].versets.find(v => v.verseKey === verseKey);
      if (verset && verset.url) {
        console.log(`Utilisation de l'URL stock√©e pour le verset ${verseKey}`);
        audioUrl = verset.url;
        isOffline = true;
      }
    }
  } catch (error) {
    console.error("Erreur lors de la v√©rification de l'audio hors ligne:", error);
  }
  
  // Si l'audio n'est pas disponible hors ligne, utiliser l'URL en ligne
  if (!audioUrl) {
    const reciterId = reciterSelect.value;
    audioUrl = `${ALQURAN_AUDIO_URL}${reciterId}/${verseKey}.mp3`;
  }
  
  // V√©rifier si ce verset est d√©j√† pr√©charg√©
  if (preloadedVerses[verseKey] && !isOffline) {
    console.log("Using preloaded audio from cache for:", verseKey);
    audioPlayerElement.src = preloadedVerses[verseKey];
    delete preloadedVerses[verseKey]; // Lib√©rer la m√©moire
  } else {
    console.log(`Loading audio from: ${isOffline ? 'cached URL' : 'online source'}`);
    audioPlayerElement.src = audioUrl;
  }
  
  // Activer le style du conteneur de verset
  const verseContainer = document.getElementById(`verse-${verseKey}`);
  if (verseContainer) {
    verseContainer.classList.add("active");
    const existingLoadingIndicator = verseContainer.querySelector('.audio-loading');
    if (existingLoadingIndicator) existingLoadingIndicator.remove();
    const oldFallback = verseContainer.querySelector('.fallback-message');
    if (oldFallback) oldFallback.remove();
    verseContainer.scrollIntoView({ behavior: "smooth", block: "center" });
  }
  
  // D√©sactiver le volume fade-out/fade-in pour une transition imm√©diate
  audioPlayerElement.volume = 1.0;
  
  // Jouer l'audio imm√©diatement
  const playPromise = audioPlayerElement.play();
  
  if (playPromise !== undefined) {
    playPromise
      .then(() => {
        console.log("Playback started for verse:", verseKey);
        isPlaying = true;
        currentVerse = verseKey;
        
        // Synchroniser les contr√¥les de lecture
        syncPlaybackControls(true);
        updateVerseInfo();
        updateMiniPlayer();
        highlightCurrentVerse(verseKey);
        
        // OPTIMISATION: Pr√©charger beaucoup plus t√¥t - d√®s 30% du verset
        audioPlayerElement.ontimeupdate = function() {
          if (!isPreloadingNext && audioPlayerElement.duration > 0 && 
              audioPlayerElement.currentTime > audioPlayerElement.duration * 0.3) {
            preloadFutureVerses(lastPlayedIndex);
            isPreloadingNext = true;
          }
        };
      })
      .catch(error => {
        console.error("Error starting playback:", error);
        if (isOffline) {
          // Si la lecture locale √©choue, essayer la version en ligne
          console.log("Local URL playback failed, trying online source");
          const reciterId = reciterSelect.value;
          audioPlayerElement.src = `${ALQURAN_AUDIO_URL}${reciterId}/${verseKey}.mp3`;
          audioPlayerElement.play().catch(err => {
            console.error("Online playback also failed:", err);
            tryDirectApiAudio(verseKey);
          });
        } else {
          tryDirectApiAudio(verseKey);
        }
      });
  }
}

// Fonction am√©lior√©e pour pr√©charger plusieurs versets √† l'avance
function preloadFutureVerses(currentIndex) {
  const nextIndex = currentIndex + 1;
  const futureIndex = currentIndex + 2;
  
  // Pr√©charger le verset suivant avec haute priorit√©
  if (nextIndex < audioQueue.length) {
    const nextVerseKey = audioQueue[nextIndex];
    preloadVerseAudio(nextVerseKey, nextAudioElement, true);
  }
  
  // Pr√©charger le verset d'apr√®s en arri√®re-plan
  if (futureIndex < audioQueue.length) {
    const futureVerseKey = audioQueue[futureIndex];
    setTimeout(() => {
      preloadVerseAudio(futureVerseKey, futureAudioElement, false);
    }, 100); // L√©ger d√©lai pour ne pas surcharger le r√©seau
  }
}

// Fonction optimis√©e pour pr√©charger un verset sp√©cifique
function preloadVerseAudio(verseKey, audioElement, isHighPriority = false) {
  if (!verseKey) return;
  
  const reciterId = reciterSelect.value;
  const audioUrl = `${ALQURAN_AUDIO_URL}${reciterId}/${verseKey}.mp3`;
  console.log(`Preloading verse ${verseKey} with ${isHighPriority ? 'high' : 'normal'} priority`);
  
  // OPTIMISATION: Utiliser fetch pour pr√©charger avec un contr√¥le plus pr√©cis
  if (isHighPriority) {
    // Pr√©chargement de haute priorit√© pour le verset suivant
    audioElement.src = audioUrl;
    audioElement.load();
    
    // Assurer que l'√©l√©ment est pr√™t √† jouer
    audioElement.oncanplaythrough = function() {
      console.log("Next verse preloaded successfully:", verseKey);
      preloadedVerses[verseKey] = audioUrl;
    };
  } else {
    // Pr√©chargement en arri√®re-plan avec fetch pour les versets futurs
    fetch(audioUrl)
      .then(response => {
        if (!response.ok) throw new Error('Network response was not ok');
        // Stocker l'URL dans le cache
        preloadedVerses[verseKey] = audioUrl;
        console.log("Future verse pre-fetched successfully:", verseKey);
      })
      .catch(error => {
        console.error("Error pre-fetching verse:", error);
      });
  }
}

// Essayer de charger l'audio directement depuis l'API Alquran.cloud
async function tryDirectApiAudio(verseKey) {
  let audioPlayedSuccessfully = false;
  
  try {
    const [surahNum, verseNum] = verseKey.split(':');
    const reciterId = reciterSelect.value;
    
    // Appel direct √† l'API
    const apiUrl = `${ALQURAN_CLOUD_API}ayah/${verseKey}/${reciterId}`;
    console.log("Trying direct API:", apiUrl);
    
    const response = await fetch(apiUrl);
    if (!response.ok) throw new Error("API response not OK");
    
    const data = await response.json();
    
    if (data.code === 200 && data.data && data.data.audio) {
      console.log("Got audio URL from API:", data.data.audio);
      
      audioPlayerElement.src = data.data.audio;
      audioPlayerElement.play()
        .then(() => {
          console.log("Alternative audio playing successfully");
          audioPlayedSuccessfully = true;
          isPlaying = true;
          currentVerse = verseKey;
          updateVerseInfo();
          highlightCurrentVerse(verseKey);
          syncPlaybackControls(true);
        })
        .catch(error => {
          if (!audioPlayedSuccessfully) {
            console.error("Error playing alternative audio:", error);
            tryFallbackAudio(verseKey);
          }
        });
    } else {
      throw new Error("Invalid API response");
    }
  } catch (error) {
    if (!audioPlayedSuccessfully) {
      console.error("Error with direct API:", error);
      
      // Derni√®re tentative - URL de secours
      const fallbackUrl = `https://verses.quran.com/${verseKey}.mp3`;
      tryFallbackAudio(verseKey, fallbackUrl);
    }
  }
}

// Derni√®re tentative avec l'URL de secours
function tryFallbackAudio(verseKey, fallbackUrl) {
  console.log("Trying last resort URL:", fallbackUrl);
  
  let audioPlayedSuccessfully = false;
  
  audioPlayerElement.src = fallbackUrl;
  audioPlayerElement.play()
    .then(() => {
      console.log("Fallback audio playing successfully");
      audioPlayedSuccessfully = true;
      isPlaying = true;
      currentVerse = verseKey;
      updateVerseInfo();
      highlightCurrentVerse(verseKey);
      syncPlaybackControls(true);
    })
    .catch(error => {
      if (!audioPlayedSuccessfully && audioPlayerElement.paused) {
        console.error("All audio options failed:", error);
        showFallbackMessage(verseKey, fallbackUrl, "Toutes les options audio ont √©chou√©");
      }
    });
    
  // √âcouter la lecture en cours pour s'assurer que le message n'appara√Æt pas si l'audio joue
  audioPlayerElement.addEventListener('timeupdate', function checkAudioPlaying() {
    if (audioPlayerElement.currentTime > 0 && !audioPlayerElement.paused) {
      audioPlayedSuccessfully = true;
      // Supprimer le message d'erreur s'il existe
      const verseContainer = document.getElementById(`verse-${verseKey}`);
      if (verseContainer) {
        const fallbackMessage = verseContainer.querySelector('.fallback-message');
        if (fallbackMessage) fallbackMessage.remove();
      }
      // Supprimer cet √©couteur une fois que nous avons confirm√© que l'audio fonctionne
      audioPlayerElement.removeEventListener('timeupdate', checkAudioPlaying);
    }
  });
}

// Afficher un message de solution en cas d'√©chec avec options plus d√©taill√©es
function showFallbackMessage(verseKey, audioUrl, errorMessage) {
  // Fonction d√©sactiv√©e puisque la lecture audio fonctionne correctement
  console.log("Ignoring audio error message, playback works fine");
  return;
}

// Highlight current verse with progressive animation in Apple style
function highlightCurrentVerse(verseKey) {
  // Remove highlight from all verses
  document.querySelectorAll(".verse-container").forEach(container => {
    container.classList.remove("active");
    const verseText = container.querySelector(".verse-text");
    if (verseText) {
      verseText.classList.remove("is-highlighted");
      verseText.innerHTML = verseText.textContent; // Reset any word highlighting
    }
  });
  
  // Add highlight to current verse
  const verseContainer = document.getElementById(`verse-${verseKey}`);
  if (verseContainer) {
    verseContainer.classList.add("active");
    verseContainer.scrollIntoView({ behavior: "smooth", block: "center" });
    
    // Get the verse text element
    const verseText = verseContainer.querySelector(".verse-text");
    if (!verseText) return;
    
    // Add highlight to the verse text
    verseText.classList.add("is-highlighted");
    
    // Create word-by-word highlighting effect
    const originalText = verseText.textContent;
    const words = originalText.split(" ").filter(word => word.trim() !== "");
    
    // Calculate time per word based on audio duration
    // If the audio is very short or duration isn't available, use a default
    const minTimePerWord = 0.3; // minimum time in seconds
    const timePerWord = audioPlayerElement.duration 
      ? Math.max(minTimePerWord, audioPlayerElement.duration / words.length) 
      : minTimePerWord;
    
    // Prepare the HTML for the text with word spans
    let html = "";
    words.forEach((word, index) => {
      html += `<span class="highlight-word" data-index="${index}">${word}</span> `;
    });
    verseText.innerHTML = html;
    
    // Clear any existing interval
    if (highlightInterval) clearInterval(highlightInterval);
    
    let wordIndex = 0;
    
    // Highlight the first word immediately
    const firstWord = verseText.querySelector(`[data-index="0"]`);
    if (firstWord) firstWord.classList.add("active");
    
    // Create new interval for word highlighting with a smoother, more Apple-like effect
    highlightInterval = setInterval(() => {
      // Remove highlight from previous word
      const prevWord = verseText.querySelector(`[data-index="${wordIndex}"]`);
      if (prevWord) prevWord.classList.remove("active");
      
      // Move to next word
      wordIndex++;
      
      if (wordIndex < words.length) {
        // Highlight next word
        const nextWord = verseText.querySelector(`[data-index="${wordIndex}"]`);
        if (nextWord) {
          nextWord.classList.add("active");
          
          // If the word is outside the viewport, scroll to it smoothly
          const wordRect = nextWord.getBoundingClientRect();
          const containerRect = verseContainer.getBoundingClientRect();
          if (wordRect.right > containerRect.right || wordRect.left < containerRect.left) {
            nextWord.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
          }
        }
      } else {
        // We're done with all words, clear the interval
        clearInterval(highlightInterval);
        highlightInterval = null;
      }
    }, timePerWord * 1000);
  }
}

// Mettre √† jour la fonction playAudio
function playAudio() {
  if (!currentSurah) {
    console.log("No surah selected");
    return;
  }
  
  if (audioPlayerElement.paused) {
    if (currentVerse && audioQueue.includes(currentVerse)) {
      // Resume current audio
      console.log("Resuming audio for verse", currentVerse);
      audioPlayerElement.play()
        .then(() => {
          console.log("Audio resumed successfully");
          isPlaying = true;
          syncPlaybackControls(true);
          updateMiniPlayer();
        })
        .catch(error => {
          console.error("Error resuming audio:", error);
          // Essayer de recharger l'audio
          playVerseAudio(currentVerse);
        });
    } else {
      // Create queue of all verses if not already created
      if (audioQueue.length === 0) {
        console.log("Creating new audio queue");
        document.querySelectorAll(".verse-audio-button").forEach(button => {
          audioQueue.push(button.dataset.verseKey);
        });
      }
      
      console.log("Audio queue has", audioQueue.length, "verses");
      
      if (audioQueue.length > 0) {
        // Jouer le premier verset ou reprendre au dernier jou√©
        const verseToPlay = lastPlayedIndex >= 0 && lastPlayedIndex < audioQueue.length - 1 
          ? audioQueue[lastPlayedIndex + 1]  // Reprendre au suivant du dernier
          : audioQueue[0];                  // Ou commencer au d√©but
          
        console.log("Starting playback with verse", verseToPlay);
        playVerseAudio(verseToPlay);
      }
    }
  }
}

// Mettre √† jour la fonction pauseAudio
function pauseAudio() {
  console.log("Pausing audio");
  audioPlayerElement.pause();
  isPlaying = false;
  syncPlaybackControls(false);
  
  // Clear word highlighting
  if (highlightInterval) {
    clearInterval(highlightInterval);
    highlightInterval = null;
  }
}

// Play the next verse in the queue
function playNextVerse() {
  return playNextVerseStrict();
}

// Fonction am√©lior√©e pour jouer le verset pr√©c√©dent
function playPreviousVerse() {
  if (audioQueue.length === 0) {
    console.log("Audio queue is empty");
    return false;
  }
  
  const prevIndex = lastPlayedIndex - 1;
  
  if (prevIndex >= 0) {
    const prevVerseKey = audioQueue[prevIndex];
    console.log(`Playing previous verse: ${prevVerseKey} (index ${prevIndex}/${audioQueue.length-1})`);
    
    // Arr√™ter l'audio actuel et r√©initialiser l'√©tat
    isPlaying = false;
    audioPlayerElement.pause();
    audioPlayerElement.currentTime = 0;
    
    // Jouer imm√©diatement le verset pr√©c√©dent sans d√©lai
    playVerseAudio(prevVerseKey);
    
    return true;
  }
  
  return false;
}

// Fonction am√©lior√©e pour jouer le verset suivant avec v√©rification stricte
function playNextVerseStrict() {
  if (audioQueue.length === 0) {
    console.log("Audio queue is empty, nothing to play");
    return false;
  }
  
  // Utiliser lastPlayedIndex+1 pour d√©terminer le prochain verset
  const nextIndex = lastPlayedIndex + 1;
  
  if (nextIndex < audioQueue.length) {
    const nextVerseKey = audioQueue[nextIndex];
    console.log(`Playing next verse: ${nextVerseKey} (index ${nextIndex}/${audioQueue.length-1})`);
    
    // Arr√™ter l'audio actuel et r√©initialiser l'√©tat
    isPlaying = false;
    audioPlayerElement.pause();
    audioPlayerElement.currentTime = 0;
    
    // Jouer imm√©diatement le verset suivant sans d√©lai
    playVerseAudio(nextVerseKey);
    
    return true;
  } else {
    // Fin de la lecture de la sourate
    console.log("End of surah reached (index", lastPlayedIndex, "of", audioQueue.length - 1, ")");
    isPlaying = false;
    currentTimeElement.textContent = "0:00";
    progressBarElement.style.width = "0%";
    syncPlaybackControls(false);
    updateVerseInfo();
    return false;
  }
}

// Mettre √† jour la fonction updateProgressBar pour synchroniser les barres de progression
function updateProgressBar() {
  if (audioPlayerElement.duration) {
    const percentage = (audioPlayerElement.currentTime / audioPlayerElement.duration) * 100;
    progressBarElement.style.width = percentage + "%";
    
    // Mettre √† jour aussi la barre de progression du mini-player
    miniProgressBar.style.width = percentage + "%";
  }
}

// Seek audio to a specific position
function seekAudio(event) {
  const rect = audioProgressElement.getBoundingClientRect();
  const pos = (event.clientX - rect.left) / rect.width;
  audioPlayerElement.currentTime = pos * audioPlayerElement.duration;
}

// Fonction pour formater le temps (secondes -> MM:SS)
function formatTime(time) {
  if (isNaN(time)) return "0:00";
  
  const minutes = Math.floor(time / 60);
  const seconds = Math.floor(time % 60).toString().padStart(2, '0');
  return `${minutes}:${seconds}`;
}

// Mettre √† jour les informations de temps et de verset pendant la lecture
audioPlayerElement.addEventListener("timeupdate", () => {
  // Mettre √† jour le temps actuel
  currentTimeElement.textContent = formatTime(audioPlayerElement.currentTime);
  
  // Mettre √† jour la barre de progression
  if (audioPlayerElement.duration) {
    const percentage = (audioPlayerElement.currentTime / audioPlayerElement.duration) * 100;
    progressBarElement.style.width = percentage + "%";
  }
});

// Mettre √† jour la dur√©e lorsque les m√©tadonn√©es sont charg√©es
audioPlayerElement.addEventListener("loadedmetadata", () => {
  durationElement.textContent = formatTime(audioPlayerElement.duration);
});

// Activer les boutons de contr√¥le lorsqu'une sourate est charg√©e
function updateControlButtons() {
  const hasAudioQueue = audioQueue.length > 0;
  previousVerseButton.disabled = !hasAudioQueue || !currentVerse || audioQueue.indexOf(currentVerse) <= 0;
  nextVerseButton.disabled = !hasAudioQueue || !currentVerse || audioQueue.indexOf(currentVerse) >= audioQueue.length - 1;
  repeatVerseButton.disabled = !currentVerse;
}

// Mettre √† jour les infos du verset en cours de lecture
function updateVerseInfo() {
  if (currentVerse && currentSurah) {
    const parts = currentVerse.split(':');
    verseInfoElement.textContent = `Sourate: ${currentSurah.name_simple} | Verset: ${parts[1]}`;
    updateControlButtons();
    updateMiniPlayer();
  } else {
    verseInfoElement.textContent = "Sourate: -- | Verset: --";
    // Ne pas cacher le mini-player
    // miniPlayer.classList.remove("active");
  }
}

// Load surahs on initial page load
loadSurahs();

// Fonction pour mettre √† jour l'image du r√©citateur
async function updateReciterImage(reciterId) {
  try {
    const response = await fetch(`https://api.quran.com/api/v4/resources/recitations/${reciterId}/reciter/${reciterId}`);
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de l\'image du r√©citateur:', error);
  }
}

// Mise √† jour de la barre de progression
audioPlayerElement.addEventListener('timeupdate', () => {
  const progress = (audioPlayerElement.currentTime / audioPlayerElement.duration) * 100;
  progressBarElement.style.width = `${progress}%`;
  currentTimeDisplay.textContent = formatTime(audioPlayerElement.currentTime);
});

// Mise √† jour de la dur√©e totale
audioPlayerElement.addEventListener('loadedmetadata', () => {
  durationDisplay.textContent = formatTime(audioPlayerElement.duration);
});

// Gestionnaire pour le volume
volumeSlider.addEventListener('input', (e) => {
  audioPlayerElement.volume = e.target.value;
});

// Mise √† jour de l'image du r√©citateur lors du changement de r√©citateur
reciterSelect.addEventListener('change', (e) => {
  updateReciterImage(e.target.value);
});

// Initialisation de l'application et des composants
async function initApp() {
  console.log("Initialisation de l'application");
  
  // Initialisation du th√®me
  initTheme();
  
  try {
    // Charger les sourates
    await loadSurahs();
    
    // Initialiser les fonctionnalit√©s principales apr√®s le chargement des sourates
    initPrayer();
    updateSystemTime();
    setInterval(updateSystemTime, 1000);
    
    // Infos m√©t√©o
    initWeather();
    
    // V√©rifier s'il y a un t√©l√©chargement en cours (reprendre apr√®s un rechargement)
    checkPendingDownloads();
    
    // Lecture audio
    initPlayer();
    
    // Mini-widgets m√©t√©o et pri√®re
    initInfoWidgets();
    
    // Afficher l'heure du syst√®me avec hadith du jour
    await updateWelcomeMessage();
    
    // V√©rifier si une sourate a √©t√© pr√©c√©demment s√©lectionn√©e et la charger
    const lastReadSurah = localStorage.getItem('lastReadSurah');
    if (lastReadSurah) {
      const surahData = JSON.parse(lastReadSurah);
      if (surahData.id) {
        document.querySelector('.resume-button').disabled = false;
        document.querySelector('.resume-button').addEventListener('click', () => {
          loadSurah(surahData.id);
        });
      }
    }
  } catch (error) {
    console.error("Erreur lors du chargement initial:", error);
  }
}

// Initialisation compl√®te du lecteur au d√©marrage
function initPlayer() {
  // Afficher toujours le mini-player
  miniPlayer.classList.add("active");
  
  // Synchroniser les boutons
  pauseButtonMain.style.display = "none";
  playButtonMain.style.display = "flex";
  
  // D√©sactiver les boutons de contr√¥le jusqu'√† ce qu'une sourate soit charg√©e
  playButtonMain.disabled = true;
  pauseButtonMain.disabled = true;
  
  // D√©sactiver l'animation de l'equalizer
  equalizerElement.classList.remove("active");
}

// Supprimer la fonction initInfoWidgets() et la remplacer par une fonction vide
function initInfoWidgets() {
  // Fonction vide car les widgets ont √©t√© supprim√©s
  console.log("Info widgets d√©sactiv√©s");
}

// Initialiser le lecteur au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
  // Initialiser l'app et le lecteur
  initApp();
  initPlayer();
  // L'initialisation de la m√©t√©o est maintenant g√©r√©e par initApp avec un d√©lai
  
  // √âcouter l'√©v√©nement pour afficher la section √Ä propos depuis le menu
  ipcRenderer.on('show-about', () => {
    if (typeof showAboutSection === 'function') {
      showAboutSection();
    } else {
      console.error("La fonction showAboutSection n'est pas disponible");
    }
  });
});

// Update weather UI with API data
function updateWeatherUI(data) {
  console.log("Ancienne fonction updateWeatherUI appel√©e, sans effet");
  // Ne rien faire, cette fonction est obsol√®te mais est appel√©e par certaines parties du code
  // Ne PAS rediriger vers getWeatherData car cela cr√©erait une boucle infinie
} 

// Initialisation des horaires de pri√®re
function initPrayer() {
  // S'assurer que tous les √©l√©ments du DOM sont r√©cup√©r√©s
  prayerModal = document.getElementById('prayer-modal');
  prayerToggle = document.getElementById('prayer-toggle');
  prayerModalClose = document.getElementById('prayer-modal-close');
  
  if (!prayerModal || !prayerToggle || !prayerModalClose) {
    console.error('√âl√©ments des horaires de pri√®re introuvables dans le DOM');
    return;
  }
  
  // √âv√©nement pour fermer la modale des pri√®res
  prayerModalClose.addEventListener('click', () => {
    console.log('Fermeture de la modale des pri√®res');
    prayerModal.classList.remove('active');
  });

  // Fermer la modale si on clique en dehors
  prayerModal.querySelector('.ios-modal-backdrop').addEventListener('click', () => {
    prayerModal.classList.remove('active');
  });
  
  // √âv√©nement pour ouvrir la modale des pri√®res
  prayerToggle.addEventListener('click', () => {
    console.log('Ouverture de la modale des pri√®res');
    prayerModal.classList.add('active');
    
    // Mettre √† jour l'heure imm√©diatement √† l'ouverture
    updateSystemTime();
    
    // Charger les donn√©es de pri√®re
    const cachedTimestamp = localStorage.getItem('prayerTimestamp');
    const currentTime = new Date().getTime();
    
    if (!cachedTimestamp || (currentTime - cachedTimestamp > 3600000)) {
      getPrayerTimes();
    }
  });
  
  console.log('Modale de pri√®re initialis√©e');
  
  // Initialiser le compte √† rebours des pri√®res
  initPrayerCountdown();
  
  // Pr√©charger les donn√©es de pri√®re en arri√®re-plan d√®s le chargement de la page
  setTimeout(() => {
    getPrayerTimes();
  }, 2000); // D√©lai de 2 secondes pour ne pas bloquer le chargement initial de la page
}

// Obtenir les horaires de pri√®re
function getPrayerTimes() {
  // Afficher un texte de chargement
  updatePrayerLoading(true);
  
  // V√©rifier si on a des donn√©es en cache
  const cachedPrayerData = localStorage.getItem('prayerData');
  const cachedTimestamp = localStorage.getItem('prayerTimestamp');
  const currentTime = new Date().getTime();
  
  // Si on a des donn√©es en cache qui datent de moins de 6 heures (21600000 ms), les utiliser
  if (cachedPrayerData && cachedTimestamp && (currentTime - cachedTimestamp < 21600000)) {
    try {
      const prayerData = JSON.parse(cachedPrayerData);
      updatePrayerInterface(prayerData);
      updatePrayerLoading(false);
      return;
    } catch (error) {
      console.error('Erreur lors de la lecture du cache des pri√®res:', error);
      // Continuer pour r√©cup√©rer de nouvelles donn√©es
    }
  }
  
  // Si on a d√©j√† des coordonn√©es, utiliser l'API par coordonn√©es
  if (userLocation.latitude && userLocation.longitude) {
    console.log("Utilisation des coordonn√©es pour les horaires de pri√®re:", userLocation);
    prayerSettings.latitude = userLocation.latitude;
    prayerSettings.longitude = userLocation.longitude;
    getPrayerTimesWithCoordinates();
    return;
  }
  
  // Si une ville a √©t√© sp√©cifi√©e par l'utilisateur, l'utiliser
  if (prayerSettings.city) {
    getPrayerTimesWithCity();
    return;
  }
  
  // Sinon, attendre les coordonn√©es de g√©olocalisation
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        prayerSettings.latitude = position.coords.latitude;
        prayerSettings.longitude = position.coords.longitude;
        getPrayerTimesWithCoordinates();
      },
      (error) => {
        console.warn('Erreur de g√©olocalisation pour les pri√®res:', error);
        // Utiliser une ville par d√©faut (Paris)
        prayerSettings.city = 'Paris';
        getPrayerTimesWithCity();
      },
      {
        timeout: 5000,
        maximumAge: 300000 // 5 minutes
      }
    );
  } else {
    console.warn('La g√©olocalisation n\'est pas support√©e, utilisation d\'une ville par d√©faut');
    prayerSettings.city = 'Paris';
    getPrayerTimesWithCity();
  }
}

// Obtenir les horaires de pri√®re avec des coordonn√©es
async function getPrayerTimesWithCoordinates() {
  try {
    const today = new Date();
    const date = `${today.getDate()}-${today.getMonth() + 1}-${today.getFullYear()}`;
    
    console.log(`R√©cup√©ration des horaires de pri√®re pour les coordonn√©es: ${prayerSettings.latitude}, ${prayerSettings.longitude}, date: ${date}, m√©thode: ${prayerSettings.method}`);
    
    const url = `${PRAYER_API_URL_COORDINATES}/${date}?latitude=${prayerSettings.latitude}&longitude=${prayerSettings.longitude}&method=${prayerSettings.method}`;
    console.log(`URL API de pri√®re: ${url}`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('R√©ponse API de pri√®re:', data);
    
    if (data.code === 200 && data.status === 'OK') {
      // V√©rifier la pr√©sence des donn√©es n√©cessaires
      if (!data.data || !data.data.date || !data.data.date.hijri) {
        console.error('Structure de donn√©es de pri√®re invalide:', data);
        throw new Error('Structure de donn√©es de pri√®re invalide');
      }
      
      // V√©rifier que toutes les donn√©es requises sont pr√©sentes
      if (!data.data.timings || !data.data.timings.Fajr) {
        console.error('Donn√©es d\'horaires de pri√®re manquantes:', data);
        throw new Error('Donn√©es d\'horaires de pri√®re manquantes');
      }
      
      // Mettre en cache les donn√©es
      localStorage.setItem('prayerData', JSON.stringify(data.data));
      localStorage.setItem('prayerTimestamp', new Date().getTime().toString());
      
      // Mettre √† jour l'interface
      updatePrayerInterface(data.data);
    } else {
      console.error('Donn√©es de pri√®re invalides:', data);
      throw new Error(`Donn√©es de pri√®re invalides: ${data.status || 'Erreur inconnue'}`);
    }
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des horaires de pri√®re:', error);
    
    // Afficher un message d'erreur dans l'interface
    document.getElementById('prayer-hijri-date').textContent = 'Erreur: Impossible de charger les donn√©es';
    
    // Essayer d'utiliser les donn√©es en cache m√™me si elles sont anciennes
    const cachedPrayerData = localStorage.getItem('prayerData');
    if (cachedPrayerData) {
      try {
        console.log('Tentative d\'utilisation du cache de secours pour les pri√®res');
        const prayerData = JSON.parse(cachedPrayerData);
        updatePrayerInterface(prayerData);
      } catch (e) {
        console.error('Erreur avec le cache de secours des pri√®res:', e);
      }
    }
  } finally {
    updatePrayerLoading(false);
  }
}

// Obtenir les horaires de pri√®re avec une ville
async function getPrayerTimesWithCity() {
  try {
    const today = new Date();
    const date = `${today.getDate()}-${today.getMonth() + 1}-${today.getFullYear()}`;
    
    console.log(`R√©cup√©ration des horaires de pri√®re pour la ville: ${prayerSettings.city}, date: ${date}, m√©thode: ${prayerSettings.method}`);
    
    const url = `${PRAYER_API_URL}/${date}?city=${encodeURIComponent(prayerSettings.city)}&country=${prayerSettings.country}&method=${prayerSettings.method}`;
    console.log(`URL API de pri√®re: ${url}`);
    
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Erreur HTTP: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('R√©ponse API de pri√®re:', data);
    
    if (data.code === 200 && data.status === 'OK') {
      // V√©rifier la pr√©sence des donn√©es n√©cessaires
      if (!data.data || !data.data.date || !data.data.date.hijri) {
        console.error('Structure de donn√©es de pri√®re invalide:', data);
        throw new Error('Structure de donn√©es de pri√®re invalide');
      }
      
      // V√©rifier que toutes les donn√©es requises sont pr√©sentes
      if (!data.data.timings || !data.data.timings.Fajr) {
        console.error('Donn√©es d\'horaires de pri√®re manquantes:', data);
        throw new Error('Donn√©es d\'horaires de pri√®re manquantes');
      }
      
      // Mettre en cache les donn√©es
      localStorage.setItem('prayerData', JSON.stringify(data.data));
      localStorage.setItem('prayerTimestamp', new Date().getTime().toString());
      
      // Mettre √† jour l'interface
      updatePrayerInterface(data.data);
    } else {
      console.error('Donn√©es de pri√®re invalides:', data);
      throw new Error(`Donn√©es de pri√®re invalides: ${data.status || 'Erreur inconnue'}`);
    }
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des horaires de pri√®re:', error);
    
    // Afficher un message d'erreur dans l'interface
    document.getElementById('prayer-hijri-date').textContent = 'Erreur: Impossible de charger les donn√©es';
    
    // Essayer d'utiliser les donn√©es en cache m√™me si elles sont anciennes
    const cachedPrayerData = localStorage.getItem('prayerData');
    if (cachedPrayerData) {
      try {
        console.log('Tentative d\'utilisation du cache de secours pour les pri√®res');
        const prayerData = JSON.parse(cachedPrayerData);
        updatePrayerInterface(prayerData);
      } catch (e) {
        console.error('Erreur avec le cache de secours des pri√®res:', e);
      }
    }
  } finally {
    updatePrayerLoading(false);
  }
}

// Mettre √† jour l'interface avec les donn√©es de pri√®re
function updatePrayerInterface(data) {
  // Mettre √† jour la date gr√©gorienne et hijri
  document.getElementById('prayer-gregorian-date').textContent = formatDateFrench(new Date(data.date.gregorian.date));
  
  // V√©rifier et formater correctement la date hijri
  try {
    let hijriMonth = '';
    // Si le mois fran√ßais n'est pas disponible
    if (data.date.hijri && data.date.hijri.month && !data.date.hijri.month.fr) {
      // Utiliser la traduction manuelle si le mois anglais est disponible
      const monthEn = data.date.hijri.month.en;
      const monthTranslations = {
        'Muharram': 'Mouharram',
        'Safar': 'Safar',
        'Rabi al-Awwal': 'Rabi al-Awwal',
        'Rabi al-Thani': 'Rabi al-Thani',
        'Jumada al-Awwal': 'Joumada al-Oula',
        'Jumada al-Thani': 'Joumada al-Thania',
        'Rajab': 'Rajab',
        'Shaban': 'Chaabane',
        'Ramadan': 'Ramadan',
        'Shawwal': 'Chawwal',
        'Dhu al-Qadah': 'Dhou al-Qi`da',
        'Dhu al-Hijjah': 'Dhou al-Hijja'
      };
      hijriMonth = monthTranslations[monthEn] || monthEn;
    } else if (data.date.hijri && data.date.hijri.month && data.date.hijri.month.fr) {
      // Utiliser le mois fran√ßais si disponible
      hijriMonth = data.date.hijri.month.fr;
    } else {
      // Fallback si la structure attendue n'est pas pr√©sente
      hijriMonth = 'ind√©fini';
    }
    
    // S'assurer que toutes les valeurs existent
    const hijriDay = data.date.hijri && data.date.hijri.day ? data.date.hijri.day : '??';
    const hijriYear = data.date.hijri && data.date.hijri.year ? data.date.hijri.year : '????';
    
    document.getElementById('prayer-hijri-date').textContent = `${hijriDay} ${hijriMonth} ${hijriYear}`;
  } catch (error) {
    console.error('Erreur lors du formatage de la date hijri:', error, data);
    document.getElementById('prayer-hijri-date').textContent = 'Date Hijri indisponible';
  }
  
  // Mettre √† jour le nom de la ville
  const cityElement = document.getElementById('prayer-city-name');
  if (cityElement) {
    if (data.meta && data.meta.timezone) {
      // Extraire le nom de la ville depuis le fuseau horaire (ex: "Europe/Paris" -> "Paris")
      const timezoneParts = data.meta.timezone.split('/');
      const cityName = timezoneParts[timezoneParts.length - 1].replace(/_/g, ' ');
      cityElement.textContent = cityName;
    } else if (prayerSettings.city) {
      // Utiliser la ville configur√©e
      cityElement.textContent = prayerSettings.city;
    } else if (userLocation.city && userLocation.city !== 'Chargement...') {
      // Utiliser la ville de la m√©t√©o
      cityElement.textContent = userLocation.city;
    } else {
      cityElement.textContent = 'Horaires de Pri√®re';
    }
  }
  
  // Mettre √† jour les horaires de pri√®re
  document.getElementById('fajr-time').textContent = data.timings.Fajr.split(' ')[0];
  document.getElementById('sunrise-time').textContent = data.timings.Sunrise.split(' ')[0];
  document.getElementById('dhuhr-time').textContent = data.timings.Dhuhr.split(' ')[0];
  document.getElementById('asr-time').textContent = data.timings.Asr.split(' ')[0];
  document.getElementById('maghrib-time').textContent = data.timings.Maghrib.split(' ')[0];
  document.getElementById('isha-time').textContent = data.timings.Isha.split(' ')[0];
  
  // Mettre en √©vidence la pri√®re actuelle
  highlightCurrentPrayer(data.timings);
}

// Mettre en √©vidence la pri√®re actuelle
function highlightCurrentPrayer(timings) {
  // Enlever toutes les classes actives
  const prayerCards = document.querySelectorAll('.prayer-card');
  prayerCards.forEach(card => card.classList.remove('active'));
  
  // D√©terminer la pri√®re actuelle
  const now = new Date();
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  const currentTime = currentHour * 60 + currentMinute;
  
  const prayers = [
    { name: 'fajr', time: timings.Fajr.split(' ')[0] },
    { name: 'sunrise', time: timings.Sunrise.split(' ')[0] },
    { name: 'dhuhr', time: timings.Dhuhr.split(' ')[0] },
    { name: 'asr', time: timings.Asr.split(' ')[0] },
    { name: 'maghrib', time: timings.Maghrib.split(' ')[0] },
    { name: 'isha', time: timings.Isha.split(' ')[0] }
  ];
  
  const prayerTimes = prayers.map(prayer => {
    const [hours, minutes] = prayer.time.split(':').map(Number);
    return {
      name: prayer.name,
      minutes: hours * 60 + minutes
    };
  });
  
  // Trouver la pri√®re actuelle et la prochaine
  let currentPrayer = null;
  let nextPrayer = null;
  
  for (let i = 0; i < prayerTimes.length; i++) {
    if (currentTime < prayerTimes[i].minutes) {
      nextPrayer = prayerTimes[i];
      if (i > 0) {
        currentPrayer = prayerTimes[i - 1];
      } else {
        // Avant la premi√®re pri√®re du jour, la derni√®re pri√®re de la veille est actuelle
        currentPrayer = prayerTimes[prayerTimes.length - 1];
      }
      break;
    }
  }
  
  // Si on n'a pas trouv√© de pri√®re suivante, c'est qu'on est apr√®s la derni√®re
  if (!nextPrayer) {
    currentPrayer = prayerTimes[prayerTimes.length - 1];
    nextPrayer = prayerTimes[0]; // La premi√®re pri√®re du lendemain
  }
  
  // Mettre en √©vidence la pri√®re actuelle
  if (currentPrayer) {
    const currentCard = document.getElementById(`${currentPrayer.name}-card`);
    if (currentCard) {
      currentCard.classList.add('active');
    }
  }
  
  // Mettre √† jour le temps restant pour la prochaine pri√®re
  updateNextPrayerTime(nextPrayer);
}

// Mettre √† jour le temps restant pour la prochaine pri√®re
function updateNextPrayerTime(nextPrayer) {
  if (!nextPrayer) return;
  
  const now = new Date();
  let nextTime = new Date(now);
  let [hours, minutes] = nextPrayer.minutes.toString().split(':');
  
  if (!hours || !minutes) {
    const totalMinutes = nextPrayer.minutes;
    hours = Math.floor(totalMinutes / 60);
    minutes = totalMinutes % 60;
  }
  
  nextTime.setHours(parseInt(hours, 10));
  nextTime.setMinutes(parseInt(minutes, 10));
  nextTime.setSeconds(0);
  
  // Si la prochaine pri√®re est demain
  if (nextTime < now) {
    nextTime.setDate(nextTime.getDate() + 1);
  }
  
  // Calculer la diff√©rence de temps
  const diff = nextTime - now;
  const hoursDiff = Math.floor(diff / (1000 * 60 * 60));
  const minutesDiff = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  
  // Construire le texte du temps restant
  let timeRemainingText = '';
  if (hoursDiff > 0) {
    timeRemainingText += `${hoursDiff} heure${hoursDiff > 1 ? 's' : ''} `;
  }
  timeRemainingText += `${minutesDiff} minute${minutesDiff > 1 ? 's' : ''}`;
  
  // Afficher le temps restant
  const prayerName = nextPrayer.name.charAt(0).toUpperCase() + nextPrayer.name.slice(1);
  const nextPrayerElement = document.querySelector('.next-prayer-countdown');
  if (nextPrayerElement) {
    nextPrayerElement.textContent = `${prayerName} dans ${timeRemainingText}`;
  }
  
  // Stocker la r√©f√©rence √† la prochaine pri√®re pour la mise √† jour
  window.nextPrayerToUpdate = nextPrayer;
}

// Initialiser la mise √† jour du compte √† rebours des pri√®res
function initPrayerCountdown() {
  // Mettre √† jour le compte √† rebours chaque minute
  setInterval(() => {
    if (window.nextPrayerToUpdate) {
      updateNextPrayerTime(window.nextPrayerToUpdate);
    }
  }, 60000); // 60 secondes
}

// Afficher l'√©tat de chargement
function updatePrayerLoading(isLoading) {
  const prayerCards = document.querySelectorAll('.prayer-card');
  if (isLoading) {
    prayerCards.forEach(card => {
      const timeElement = card.querySelector('.prayer-time');
      if (timeElement) {
        timeElement.textContent = 'Chargement...';
      }
    });
    document.getElementById('prayer-gregorian-date').textContent = '--';
    document.getElementById('prayer-hijri-date').textContent = '--';
  }
}

// Formater la date en fran√ßais
function formatDateFrench(date) {
  const options = { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' };
  return capitalizeFirstLetter(date.toLocaleDateString('fr-FR', options));
}

// Fonction pour mettre √† jour l'horloge syst√®me
function updateSystemTime() {
  const now = new Date();
  let hours = now.getHours().toString().padStart(2, '0');
  let minutes = now.getMinutes().toString().padStart(2, '0');
  const timeString = `${hours}:${minutes}`;
  
  // Mettre √† jour l'heure dans les deux modales
  const weatherTimeElement = document.getElementById('weather-time');
  const prayerTimeElement = document.getElementById('prayer-time');
  
  if (weatherTimeElement) weatherTimeElement.textContent = timeString;
  if (prayerTimeElement) prayerTimeElement.textContent = timeString;
}

// Mettre √† jour l'heure chaque minute
setInterval(updateSystemTime, 60000);

// Mettre √† jour l'heure imm√©diatement au chargement
document.addEventListener('DOMContentLoaded', function() {
  updateSystemTime();
});

// Fonction de redirection pour assurer la compatibilit√© avec les appels existants
function preloadNextVerse(verseKey) {
  // Redirection vers la nouvelle fonction avec les param√®tres appropri√©s
  preloadVerseAudio(verseKey, nextAudioElement, true);
}

// Fonction simplifi√©e pour t√©l√©charger l'audio d'une sourate compl√®te
async function downloadSurahAudio(surahId, reciterId, downloadButton) {
  try {
    console.log("D√©but du t√©l√©chargement de la sourate:", surahId, "avec r√©citateur:", reciterId);
    
    if (!surahId) {
      console.error("ID de sourate invalide pour le t√©l√©chargement");
      return false;
    }
    
    // √âviter les t√©l√©chargements multiples
    if (downloadInProgress) {
      console.log("Un t√©l√©chargement est d√©j√† en cours");
      return false;
    }
    
    // Marquer comme en cours
    downloadInProgress = true;
    currentDownloadSurahId = surahId;
    downloadProgress = 0;
    downloadAbortController = new AbortController();
    
    // R√©cup√©rer les informations de la sourate depuis l'API si n√©cessaire
    let surahName = `Sourate ${surahId}`;
    let reciterName = "R√©citateur";
    
    // Si on a currentSurah, on utilise son nom
    if (currentSurah && currentSurah.id == surahId) {
      surahName = currentSurah.name_simple;
    } else {
      // Essayer de trouver le nom dans la liste des sourates
      const surahElement = document.querySelector(`.spotify-surah-item[data-surah-id="${surahId}"]`);
      if (surahElement) {
        const nameElement = surahElement.querySelector('.spotify-surah-name');
        if (nameElement) {
          surahName = nameElement.textContent;
        }
      }
    }
    
    // R√©cup√©rer le nom du r√©citateur
    if (currentReciter && currentReciter.api_reciter_id == reciterId) {
      reciterName = currentReciter.reciter_name;
    } else {
      // Essayer de trouver le nom du r√©citateur dans les options
      const reciterOption = document.querySelector(`option[value="${reciterId}"]`);
      if (reciterOption) {
        reciterName = reciterOption.textContent;
      }
    }
    
    console.log("Informations de sourate:", { surahId, surahName, reciterId, reciterName });
    
    // Mettre √† jour l'√©tat du bouton pass√© en param√®tre
    if (downloadButton) {
      downloadButton.classList.add('loading');
      const svg = downloadButton.querySelector('svg');
      if (svg) {
        svg.innerHTML = '<path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/>';
      }
    }
    
    // G√©n√©rer les versets √† t√©l√©charger
    const versets = [];
    
    // Si on est sur une sourate active, utiliser sa queue audio
    if (currentSurah && currentSurah.id == surahId && audioQueue && audioQueue.length > 0) {
      for (const verseKey of audioQueue) {
        const audioUrl = `${ALQURAN_AUDIO_URL}${reciterId}/${verseKey}.mp3`;
        versets.push({
          verseKey: verseKey,
          url: audioUrl
        });
      }
    } else {
      // Sinon, g√©n√©rer des versets bas√©s sur l'ID de la sourate
      try {
        const surahInfoUrl = `${QURAN_API_URL}api/v4/chapters/${surahId}`;
        const surahInfo = await fetchApi(surahInfoUrl, { 
          context: `info sourate ${surahId}`
        });
        
        if (surahInfo && surahInfo.verses_count) {
          const versesCount = surahInfo.verses_count;
          
          for (let i = 1; i <= versesCount; i++) {
            const verseKey = `${surahId}:${i}`;
            const audioUrl = `${ALQURAN_AUDIO_URL}${reciterId}/${verseKey}.mp3`;
            versets.push({
              verseKey: verseKey,
              url: audioUrl
            });
          }
        }
      } catch (error) {
        console.error("Impossible de r√©cup√©rer le nombre de versets:", error);
        throw new Error("Impossible de r√©cup√©rer les informations de la sourate");
      }
    }
    
    console.log(`${versets.length} versets √† t√©l√©charger`);
    
    // V√©rifier l'espace de stockage disponible
    try {
      const storage = await navigator.storage.estimate();
      const requiredSpace = versets.length * 500000; // Estimation de 500KB par verset
      
      if (storage.quota - storage.usage < requiredSpace) {
        throw new Error("Espace de stockage insuffisant");
      }
    } catch (error) {
      console.error("Erreur lors de la v√©rification de l'espace de stockage:", error);
      throw new Error("Impossible de v√©rifier l'espace de stockage");
    }
    
    // T√©l√©charger chaque verset
    const downloadedVersets = [];
    let completedDownloads = 0;
    
    for (const verset of versets) {
      try {
        // V√©rifier si le t√©l√©chargement a √©t√© annul√©
        if (downloadAbortController.signal.aborted) {
          throw new Error("T√©l√©chargement annul√©");
        }
        
        // T√©l√©charger le fichier audio
        const response = await fetch(verset.url, {
          signal: downloadAbortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`Erreur HTTP: ${response.status}`);
        }
        
        // Convertir en ArrayBuffer
        const audioData = await response.arrayBuffer();
        
        // Convertir en Base64 pour le stockage
        const base64Audio = uint8ArrayToBase64(new Uint8Array(audioData));
        
        // Ajouter aux versets t√©l√©charg√©s
        downloadedVersets.push({
          ...verset,
          audioData: base64Audio
        });
        
        // Mettre √† jour la progression
        completedDownloads++;
        downloadProgress = Math.floor((completedDownloads / versets.length) * 100);
        
        // Mettre √† jour le bouton si disponible
        if (downloadButton) {
          const progressPct = downloadProgress + '%';
          downloadButton.setAttribute('data-progress', progressPct);
        }
        
        // Sauvegarder la progression dans localStorage
        localStorage.setItem('pendingDownload', JSON.stringify({
          surahId: surahId,
          reciterId: reciterId,
          progress: downloadProgress,
          timestamp: new Date().toISOString(),
          downloadedVersets: downloadedVersets.map(v => v.verseKey)
        }));
        
      } catch (error) {
        console.error(`Erreur lors du t√©l√©chargement du verset ${verset.verseKey}:`, error);
        
        // Si c'est une annulation, arr√™ter le t√©l√©chargement
        if (error.message === "T√©l√©chargement annul√©") {
          break;
        }
        
        // Pour les autres erreurs, continuer avec le verset suivant
        continue;
      }
    }
    
    // Finaliser le t√©l√©chargement
    if (downloadedVersets.length > 0) {
      await finishDownload(surahId, surahName, reciterName, downloadedVersets);
      
      // Mettre √† jour le bouton sp√©cifique
      if (downloadButton) {
        downloadButton.classList.remove('loading');
        downloadButton.classList.add('downloaded');
        const svg = downloadButton.querySelector('svg');
        if (svg) {
          svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>';
        }
        downloadButton.title = 'T√©l√©chargement termin√©';
      }
      
      return true;
    } else {
      throw new Error("Aucun verset n'a pu √™tre t√©l√©charg√©");
    }
    
  } catch (error) {
    console.error("Erreur lors du t√©l√©chargement de la sourate:", error);
    
    // R√©initialiser le t√©l√©chargement en cas d'erreur
    downloadInProgress = false;
    currentDownloadSurahId = null;
    downloadProgress = 0;
    
    // R√©initialiser le bouton sp√©cifique
    if (downloadButton) {
      downloadButton.classList.remove('loading');
      const svg = downloadButton.querySelector('svg');
      if (svg) {
        svg.innerHTML = '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
      }
    }
    
    // Afficher la notification d'erreur
    showNotification('Erreur de t√©l√©chargement', error.message);
    
    return false;
  } finally {
    // Nettoyer le localStorage si le t√©l√©chargement est termin√© ou annul√©
    if (!downloadInProgress) {
      localStorage.removeItem('pendingDownload');
    }
  }
}

// Fonction pour v√©rifier si une sourate est disponible hors ligne
function checkOfflineAvailability(surahId) {
  try {
    // V√©rifier dans localStorage
    const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
    const isOffline = offlineAudio[surahId] !== undefined;
    
    if (isOffline) {
      console.log(`Sourate ${surahId} disponible hors ligne (localStorage)`);
    }
    
    return isOffline;
  } catch (error) {
    console.error("Erreur lors de la v√©rification de la disponibilit√© hors ligne:", error);
    return false;
  }
}

// Fonction pour convertir un Uint8Array en base64 de mani√®re s√©curis√©e (pour les grands fichiers)
function uint8ArrayToBase64(uint8Array) {
  let binary = '';
  const chunk = 8192; // Traiter par morceaux pour √©viter les d√©passements de taille de pile
  
  for (let i = 0; i < uint8Array.length; i += chunk) {
    const subArray = uint8Array.subarray(i, Math.min(i + chunk, uint8Array.length));
    binary += String.fromCharCode.apply(null, subArray);
  }
  
  return btoa(binary);
}

// Fonction pour terminer le t√©l√©chargement avec succ√®s
async function finishDownload(surahId, surahName, reciterName, versets) {
  try {
    // Cr√©er un dossier pour la sourate dans le stockage local
    const surahDir = `surahs/${surahId}_${reciterId}`;
    
    // Enregistrer les m√©tadonn√©es de la sourate
    const surahMetadata = {
      id: surahId,
      name: surahName,
      translatedName: currentSurah ? currentSurah.translated_name.name : "",
      reciter: reciterName,
      timestamp: new Date().toISOString(),
      totalVerses: versets.length,
      version: "1.0" // Pour la gestion des versions futures
    };
    
    // Enregistrer les m√©tadonn√©es
    const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
    offlineAudio[surahId] = surahMetadata;
    localStorage.setItem('offlineAudio', JSON.stringify(offlineAudio));
    
    // Cr√©er un dossier pour les fichiers audio
    try {
      await window.showDirectoryPicker({
        mode: 'readwrite',
        startIn: 'downloads'
      });
    } catch (error) {
      console.warn("Impossible de cr√©er un dossier, utilisation du stockage local:", error);
    }
    
    // Sauvegarder chaque verset
    for (const verset of versets) {
      try {
        // Cr√©er une cl√© unique pour le verset
        const verseKey = `verse_${verset.verseKey.replace(':', '_')}`;
        
        // Sauvegarder les donn√©es audio
        localStorage.setItem(`${surahDir}/${verseKey}`, verset.audioData);
        
        // Mettre √† jour les m√©tadonn√©es avec les informations du verset
        if (!offlineAudio[surahId].verses) {
          offlineAudio[surahId].verses = {};
        }
        
        offlineAudio[surahId].verses[verset.verseKey] = {
          key: verset.verseKey,
          size: verset.audioData.length,
          timestamp: new Date().toISOString()
        };
        
        // Sauvegarder les m√©tadonn√©es mises √† jour
        localStorage.setItem('offlineAudio', JSON.stringify(offlineAudio));
        
      } catch (error) {
        console.error(`Erreur lors de la sauvegarde du verset ${verset.verseKey}:`, error);
        // Continuer avec le verset suivant
        continue;
      }
    }
    
    console.log("T√©l√©chargement termin√© pour la sourate:", surahId);
    console.log("Donn√©es sauvegard√©es:", offlineAudio[surahId]);
    
    // Montrer une notification
    showNotification('Sourate t√©l√©charg√©e', 'Disponible hors ligne');
    
    // R√©initialiser les variables globales
    downloadInProgress = false;
    currentDownloadSurahId = null;
    
    return true;
  } catch (error) {
    console.error("Erreur lors de la finalisation du t√©l√©chargement:", error);
    showNotification('Erreur de t√©l√©chargement', error.message);
    
    // R√©initialiser les variables globales
    downloadInProgress = false;
    currentDownloadSurahId = null;
    
    return false;
  }
}

// Fonction pour afficher une notification de t√©l√©chargement r√©ussi
function showDownloadNotification() {
  showNotification('Sourate t√©l√©charg√©e', 'Disponible hors ligne');
}

// Mettre √† jour tous les boutons de t√©l√©chargement dans l'interface
function updateDownloadButtonsState(surahId, className, labelText, isOffline = false) {
  const downloadButtons = document.querySelectorAll('.download-surah-button');
  downloadButtons.forEach(button => {
    // Retirer toutes les classes d'√©tat
    button.classList.remove('downloading', 'download-complete', 'download-error', 'is-offline');
    
    // Ajouter la nouvelle classe si sp√©cifi√©e
    if (className) {
      button.classList.add(className);
    }
    
    // Mettre √† jour le texte du label
    const downloadLabel = button.querySelector('.download-label');
    if (downloadLabel) {
      downloadLabel.textContent = labelText;
    }
    
    // Changer l'ic√¥ne si disponible hors ligne
    const iconContainer = button.querySelector('svg');
    if (iconContainer && isOffline) {
      // Remplacer l'ic√¥ne par une ic√¥ne de lecture pour indiquer que c'est disponible hors ligne
      iconContainer.innerHTML = `
        <path d="M9 18V6l10 6-10 6z"></path>
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"></circle>
      `;
    } else if (iconContainer) {
      // Remettre l'ic√¥ne de t√©l√©chargement par d√©faut
      iconContainer.innerHTML = `
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      `;
    }
  });
}

// Mettre √† jour la progression du t√©l√©chargement sur tous les boutons de t√©l√©chargement
function updateDownloadProgress(progress) {
  const progressBars = document.querySelectorAll('.download-progress-bar');
  const progressTexts = document.querySelectorAll('.download-progress-text');
  
  progressBars.forEach(bar => {
    bar.style.width = `${progress}%`;
  });
  
  progressTexts.forEach(text => {
    text.textContent = `${Math.round(progress)}%`;
  });
}

// V√©rifier s'il y a des t√©l√©chargements en cours √† reprendre
function checkPendingDownloads() {
  try {
    const pendingDownload = localStorage.getItem('pendingDownload');
    if (pendingDownload) {
      const downloadData = JSON.parse(pendingDownload);
      if (downloadData.surahId && downloadData.progress < 100) {
        // Reprendre le t√©l√©chargement o√π il s'√©tait arr√™t√©
        console.log("Reprise d'un t√©l√©chargement inachev√©:", downloadData.surahId, downloadData.progress);
        downloadInProgress = true;
        currentDownloadSurahId = downloadData.surahId;
        downloadProgress = downloadData.progress;
        downloadAbortController = new AbortController();
        
        // Mettre √† jour l'interface
        updateDownloadButtonsState(downloadData.surahId, 'downloading', 'T√©l√©chargement...');
        updateDownloadProgress(downloadData.progress);
        
        // Simuler la continuation du t√©l√©chargement
        const intervalId = setInterval(() => {
          if (downloadProgress < 100) {
            downloadProgress += 1;
            updateDownloadProgress(downloadProgress);
            
            // Sauvegarder la progression
            localStorage.setItem('pendingDownload', JSON.stringify({
              surahId: currentDownloadSurahId,
              progress: downloadProgress
            }));
            
            // Quand le t√©l√©chargement est termin√©
            if (downloadProgress >= 100) {
              clearInterval(intervalId);
              localStorage.removeItem('pendingDownload');
              // Terminer le t√©l√©chargement avec les informations disponibles
              const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
              if (offlineAudio[downloadData.surahId]) {
                // T√©l√©chargement d√©j√† finalis√© entre-temps
                downloadInProgress = false;
                currentDownloadSurahId = null;
                checkOfflineAvailability(downloadData.surahId);
              } else {
                // Finaliser avec des informations minimales
                finishDownload(downloadData.surahId, `Sourate ${downloadData.surahId}`, 'R√©citateur par d√©faut', []);
              }
            }
          }
        }, 80);
      } else {
        // T√©l√©chargement pr√©c√©dent d√©j√† termin√© ou invalide
        localStorage.removeItem('pendingDownload');
      }
    }
  } catch (error) {
    console.error("Erreur lors de la v√©rification des t√©l√©chargements en cours:", error);
    localStorage.removeItem('pendingDownload');
  }
}

// Fonction pour afficher un menu contextuel avec options pour les sourates t√©l√©charg√©es
function showOfflineOptionsMenu(surahId, buttonElement) {
  // Supprimer tout menu existant
  const existingMenu = document.querySelector('.offline-options-menu');
  if (existingMenu) {
    existingMenu.remove();
  }
  
  // Cr√©er le menu contextuel
  const menu = document.createElement('div');
  menu.className = 'offline-options-menu';
  
  // Options du menu style Apple
  menu.innerHTML = `
    <div class="menu-option play-offline" data-action="play">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span>Lire la sourate</span>
    </div>
    <div class="menu-option remove-offline" data-action="remove">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 6h18"></path>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
      </svg>
      <span>Supprimer le t√©l√©chargement</span>
    </div>
  `;
  
  // Ajouter au DOM d'abord pour pouvoir calculer la taille
  document.body.appendChild(menu);
  
  // Positionner le menu de mani√®re plus robuste
  const buttonRect = buttonElement.getBoundingClientRect();
  const menuRect = menu.getBoundingClientRect();
  
  // Calculer la position id√©ale (centr√©e sous le bouton)
  let top = buttonRect.bottom + 10; // 10px de marge
  let left = buttonRect.left + (buttonRect.width / 2) - (menuRect.width / 2);
  
  // S'assurer que le menu reste visible dans la fen√™tre
  const rightEdge = left + menuRect.width;
  const bottomEdge = top + menuRect.height;
  
  // Ajuster si n√©cessaire pour √©viter de sortir de l'√©cran
  if (rightEdge > window.innerWidth) {
    left = window.innerWidth - menuRect.width - 10;
  }
  if (left < 10) {
    left = 10; // Marge minimale √† gauche
  }
  if (bottomEdge > window.innerHeight) {
    top = buttonRect.top - menuRect.height - 10;
  }
  
  // Appliquer la position
  menu.style.top = `${top}px`;
  menu.style.left = `${left}px`;
  
  // Animation style Apple - d'abord rendre visible puis appliquer l'animation
  requestAnimationFrame(() => {
    menu.classList.add('visible');
  });
  
  // Gestionnaires d'√©v√©nements pour les options
  menu.querySelector('.play-offline').addEventListener('click', () => {
    menu.classList.remove('visible');
    setTimeout(() => {
      menu.remove();
      playOfflineSurah(surahId);
    }, 200); // Attendre la fin de l'animation
  });
  
  menu.querySelector('.remove-offline').addEventListener('click', () => {
    menu.classList.remove('visible');
    setTimeout(() => {
      menu.remove();
      removeSurahDownload(surahId);
    }, 200); // Attendre la fin de l'animation
  });
  
  // Fermer le menu quand on clique ailleurs - style Apple avec animation
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if (!menu.contains(e.target) && e.target !== buttonElement) {
        menu.classList.remove('visible');
        setTimeout(() => {
          menu.remove();
        }, 200);
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 100); // L√©ger d√©lai pour √©viter que le clic actuel ne ferme imm√©diatement le menu
}

// Fonction pour lire une sourate t√©l√©charg√©e
function playOfflineSurah(surahId) {
  try {
    // Obtenir les informations de la sourate depuis localStorage
    const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
    const surahData = offlineAudio[surahId];
    
    if (!surahData) {
      console.error("Sourate non disponible hors ligne:", surahId);
      return;
    }
    
    console.log("Lecture de la sourate hors ligne:", surahData.name);
    
    // Trouver le premier verset
    if (surahData.versets && surahData.versets.length > 0) {
      // Si la sourate actuelle n'est pas celle qu'on veut lire, la charger d'abord
      if (!currentSurah || currentSurah.id !== parseInt(surahId)) {
        loadSurah(surahId).then(() => {
          // Puis commencer la lecture depuis le premier verset
          playVerseAudio(surahData.versets[0].verseKey);
        });
      } else {
        // Sinon, commencer la lecture directement
        playVerseAudio(surahData.versets[0].verseKey);
      }
      
      // Afficher une notification
      showNotification(`Lecture de ${surahData.name}`, 'En utilisant la version t√©l√©charg√©e');
    }
  } catch (error) {
    console.error("Erreur lors de la lecture hors ligne:", error);
  }
}

// Fonction pour supprimer une sourate t√©l√©charg√©e
function removeSurahDownload(surahId) {
  try {
    // Obtenir les donn√©es actuelles
    const offlineAudio = JSON.parse(localStorage.getItem('offlineAudio') || '{}');
    
    // R√©cup√©rer le nom de la sourate avant suppression pour la notification
    const surahName = offlineAudio[surahId] ? offlineAudio[surahId].name : `Sourate ${surahId}`;
    
    // Supprimer la sourate
    if (offlineAudio[surahId]) {
      delete offlineAudio[surahId];
      localStorage.setItem('offlineAudio', JSON.stringify(offlineAudio));
      
      // Mettre √† jour l'interface
      updateDownloadButtonsState(surahId, '', 'T√©l√©charger');
      
      // Afficher une notification
      showNotification('T√©l√©chargement supprim√©', `${surahName} n'est plus disponible hors ligne`);
      
      console.log("Sourate supprim√©e des t√©l√©chargements:", surahId);
    }
  } catch (error) {
    console.error("Erreur lors de la suppression du t√©l√©chargement:", error);
  }
}

// Fonction g√©n√©ralis√©e pour afficher des notifications
function showNotification(title, message) {
  const notification = document.createElement('div');
  notification.className = 'offline-notification';
  notification.innerHTML = `
    <div class="notification-content">
      <div class="notification-icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
          <polyline points="22 4 12 14.01 9 11.01"></polyline>
        </svg>
      </div>
      <div class="notification-text">
        <strong>${title}</strong>
        <span>${message}</span>
      </div>
    </div>
  `;
  
  document.body.appendChild(notification);
  
  // Animer l'apparition et la disparition
  setTimeout(() => {
    notification.classList.add('show');
  }, 100);
  
  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => {
      if (notification.parentNode) {
        document.body.removeChild(notification);
      }
    }, 500);
  }, 3000);
}

// Spotify Player Functionality
let spotifyPlayerModal = document.getElementById('spotify-player-modal');
let spotifyPlayerButton = document.getElementById('spotify-player-button');
let spotifyCloseButton = document.getElementById('spotify-close-button');
let spotifySearchInput = document.getElementById('spotify-search-input');
let spotifyRecitersListElement = document.getElementById('spotify-reciters-list');
let spotifySurahListElement = document.getElementById('spotify-surah-list');
let spotifyAudioElement = document.getElementById('spotify-audio-player');
let currentReciter = null;
let currentSurahPlaying = null;
let allReciters = [];
let spotifyAllSurahs = [];

// Nouveaux √©l√©ments UI
let spotifyHomeMenu = document.getElementById('spotify-home');
let spotifyFavoritesMenu = document.getElementById('spotify-favorites');
let spotifyPlaylistsMenu = document.getElementById('spotify-playlists');
let spotifyDownloadedMenu = document.getElementById('spotify-downloaded');

let spotifyHomeSection = document.getElementById('spotify-home-section');
let spotifyFavoritesSection = document.getElementById('spotify-favorites-section');
let spotifyPlaylistsSection = document.getElementById('spotify-playlists-section');
let spotifyDownloadedSection = document.getElementById('spotify-downloaded-section');

let spotifyNavBack = document.getElementById('spotify-nav-back');
let spotifyNavForward = document.getElementById('spotify-nav-forward');

let spotifyLikeButton = document.getElementById('spotify-like-button');
let spotifyPlayAllButton = document.getElementById('spotify-play-all');
let spotifyAddToFavoritesButton = document.getElementById('spotify-add-to-favorites');
let spotifyCreatePlaylistButton = document.getElementById('spotify-create-playlist');
let spotifyMiniPlayerToggle = document.getElementById('spotify-mini-player-toggle');

let spotifyShuffleButton = document.getElementById('spotify-shuffle');
let spotifyRepeatButton = document.getElementById('spotify-repeat');

// Structures de donn√©es pour les nouvelles fonctionnalit√©s
let spotifyFavorites = [];
let spotifyPlaylists = [];
let spotifyRecentlyPlayed = [];
let spotifyDownloaded = [];
let spotifyNavHistory = [];
let spotifyNavPosition = -1;
let isShuffleActive = false;
let repeatMode = 'none'; // 'none', 'all', 'one'

// Top 10 renowned Quran reciters with their photos
const topReciters = [
  {
    id: 10001,
    api_reciter_id: 1, // Abdul Basit dans l'API
    reciter_name: "Abdul Basit Abdul Samad",
    style: "√âgyptien classique",
    image: "assets/images/reciters/abdul_basit.jpg",
    bio: "R√©citateur l√©gendaire connu pour sa voix m√©lodieuse et son style unique"
  },
  {
    id: 10002,
    api_reciter_id: 7, // Mishari Rashid dans l'API
    reciter_name: "Mishary Rashid Alafasy",
    style: "Kowe√Øtien moderne",
    image: "assets/images/reciters/mishary_rashid.jpg",
    bio: "Imam et r√©citateur contemporain renomm√© du Kowe√Øt"
  },
  {
    id: 10003,
    api_reciter_id: 3, // Minshawi dans l'API
    reciter_name: "Mohamed Siddiq El-Minshawi",
    style: "√âgyptien classique",
    image: "assets/images/reciters/mohamed_siddiq.jpg",
    bio: "Ma√Ætre de la r√©citation harmonieuse du 20√®me si√®cle"
  },
  {
    id: 10004,
    api_reciter_id: 5, // Al-Hussary dans l'API
    reciter_name: "Mahmoud Khalil Al-Hussary",
    style: "√âcole √©gyptienne",
    image: "assets/images/reciters/mahmoud_khalil.jpg",
    bio: "R√©citateur √©minent reconnu pour son respect m√©ticuleux des r√®gles de r√©citation"
  },
  {
    id: 10005,
    api_reciter_id: 10, // Saad Al-Ghamdi dans l'API
    reciter_name: "Saad Al-Ghamdi",
    style: "Saoudien moderne",
    image: "assets/images/reciters/saad_al_ghamdi.jpg",
    bio: "R√©citateur saoudien avec une voix claire et √©mouvante"
  },
  {
    id: 10006,
    api_reciter_id: 4, // Sudais dans l'API
    reciter_name: "Abdul Rahman Al-Sudais",
    style: "Imam de la Mecque",
    image: "assets/images/reciters/abdul_rahman.jpg",
    bio: "Imam de la Grande Mosqu√©e de La Mecque √† la voix exceptionnelle"
  },
  {
    id: 10007,
    api_reciter_id: 8, // Shuraim dans l'API
    reciter_name: "Saud Al-Shuraim",
    style: "Imam de la Mecque",
    image: "assets/images/reciters/saud_al_shuraim.jpg",
    bio: "Imam de la Sainte Mosqu√©e de La Mecque au style majestueux"
  },
  {
    id: 10008,
    api_reciter_id: 11, // Hani Rifai dans l'API
    reciter_name: "Hani Ar-Rifai",
    style: "Classique",
    image: "assets/images/reciters/hani_rifai.jpg",
    bio: "R√©citateur reconnu pour la douceur et la clart√© de sa r√©citation"
  },
  {
    id: 10009,
    api_reciter_id: 12, // Maher Al Muaiqly dans l'API
    reciter_name: "Maher Al-Muaiqly",
    style: "Contemporain saoudien",
    image: "assets/images/reciters/maher_muaiqly.jpg",
    bio: "R√©citateur √† la voix m√©lodieuse et contemporaine"
  },
  {
    id: 10010,
    api_reciter_id: 6, // Muhammad Ayyub dans l'API
    reciter_name: "Muhammad Ayyub",
    style: "Traditionnel",
    image: "assets/images/reciters/muhammad_ayyub.jpg",
    bio: "R√©citateur saoudien √† la voix puissante et expressive"
  }
];

// Load reciters - modified to include top reciters
async function loadReciters() {
  try {
    document.getElementById('spotify-reciters-list').innerHTML = '<div style="padding: 20px; color: white;">Chargement des r√©citateurs...</div>';
    
    // Utiliser uniquement notre liste des r√©citateurs renomm√©s
    allReciters = topReciters;
    
    // Afficher les r√©citateurs dans l'interface
    renderReciters(allReciters);
    
    // === ADDED CODE START ===
    // Initialize player bar with the first reciter's info
    if (allReciters && allReciters.length > 0) {
      const firstReciter = allReciters[0];
      const playerImage = document.getElementById('spotify-playing-img');
      const playerReciterName = document.getElementById('spotify-playing-reciter');
      
      if (playerImage && firstReciter.image) {
        playerImage.src = firstReciter.image;
        playerImage.alt = firstReciter.reciter_name;
      }
      
      if (playerReciterName) {
        playerReciterName.textContent = firstReciter.reciter_name;
      }
      
      // Keep the surah name as default until something is played
      const playerName = document.getElementById('spotify-playing-name');
      if (playerName) {
          playerName.textContent = 'Sourate non s√©lectionn√©e';
      }
    }
    // === ADDED CODE END ===
    
    return allReciters; // Retourner le tableau des r√©citateurs pour le cha√Ænage de promesses
  } catch (error) {
    console.error('Error loading reciters:', error);
    document.getElementById('spotify-reciters-list').innerHTML = '<div style="padding: 20px; color: white;">Erreur de chargement. Veuillez r√©essayer.</div>';
    return []; // Retourner un tableau vide en cas d'erreur
  }
}

// Render reciters in the sidebar - modified to use local images
function renderReciters(reciters) {
  // Clear previous content
  spotifyRecitersListElement.innerHTML = '';
  
  // Default local image for reciters without photos
  const defaultImage = 'assets/images/reciters/default_reciter.jpg';
  
  // Add "Featured Reciters" header
  const featuredHeader = document.createElement('div');
  featuredHeader.className = 'spotify-reciters-section-header';
  featuredHeader.textContent = 'R√©citateurs renomm√©s';
  spotifyRecitersListElement.appendChild(featuredHeader);
  
  // First render top reciters
  const topReciterIds = topReciters.map(r => r.id);
  const featuredReciters = reciters.filter(r => topReciterIds.includes(r.id));
  
  featuredReciters.forEach((reciter) => {
    const reciterItem = document.createElement('div');
    reciterItem.className = 'spotify-reciter-item';
    reciterItem.dataset.reciterId = reciter.id;
    
    // Use the reciter's local image
    const imageUrl = reciter.image || defaultImage;
    
    reciterItem.innerHTML = `
      <img src="${imageUrl}" class="spotify-reciter-img" alt="${reciter.reciter_name}" onerror="this.src='${defaultImage}'">
      <div class="spotify-reciter-info">
        <div class="spotify-reciter-name">${reciter.reciter_name}</div>
        <div class="spotify-reciter-style">${reciter.style || 'Style classique'}</div>
      </div>
    `;
    
    reciterItem.addEventListener('click', () => {
      selectReciter(reciter, imageUrl);
    });
    
    spotifyRecitersListElement.appendChild(reciterItem);
  });
}

// Function to clean up Spotify player state
function cleanupSpotifyPlayer() {
  // Arr√™ter l'audio en cours
  if (spotifyAudioElement && spotifyAudioElement.src) {
    spotifyAudioElement.pause();
    spotifyAudioElement.src = ''; // Enlever la source
  }
  
  // R√©initialiser l'affichage
  document.getElementById('spotify-playing-name').textContent = 'Sourate non s√©lectionn√©e';
  document.getElementById('spotify-playing-reciter').textContent = 'Aucun r√©citateur';
  document.getElementById('spotify-play').innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polygon points="5 3 19 12 5 21 5 3"></polygon>
    </svg>
  `;
  
  // R√©initialiser la barre de progression
  document.getElementById('spotify-progress-current').style.width = '0%';
  document.getElementById('spotify-current-time').textContent = '0:00';
  document.getElementById('spotify-total-time').textContent = '0:00';
  
  // R√©initialiser la sourate en cours de lecture
  currentSurahPlaying = null;
}

// Initialize Spotify Player
function initSpotifyPlayer() {
  if (!spotifyPlayerModal || !spotifyPlayerButton || !spotifyCloseButton) {
    console.error('Spotify player elements not found in DOM');
    return;
  }

  // Open Spotify Player Modal
  spotifyPlayerButton.addEventListener('click', () => {
    console.log('Opening Spotify Player Modal');
    
    // Pr√©parer l'animation
    document.body.style.overflow = 'hidden';
    spotifyPlayerModal.style.display = 'flex';
    
    // Load reciters if not already loaded
    if (spotifyRecitersListElement.children.length === 0) {
      loadReciters().then(() => {
        // Automatically select the first reciter when reciters are loaded
        if (allReciters.length > 0) {
          const firstReciter = allReciters[0];
          const imageUrl = firstReciter.image || 'assets/images/reciters/default_reciter.jpg';
          selectReciter(firstReciter, imageUrl);
        }
      });
    } else if (allReciters.length > 0 && !currentReciter) {
      // If reciters are already loaded but none is selected, select the first one
      const firstReciter = allReciters[0];
      const imageUrl = firstReciter.image || 'assets/images/reciters/default_reciter.jpg';
      selectReciter(firstReciter, imageUrl);
    }
    
    // Charger les r√©cemment √©cout√©s
    spotifyRecentlyPlayed = JSON.parse(localStorage.getItem('spotifyRecentlyPlayed') || '[]');
    loadRecentlyPlayed();
    
    // Par d√©faut, afficher la section d'accueil
    switchSpotifySection('home');
    
    // Initialiser l'historique de navigation
    if (spotifyNavHistory.length === 0) {
      spotifyNavHistory = ['home'];
      spotifyNavPosition = 0;
    }
    
    // Forcer le reflow pour que la transition fonctionne
    spotifyPlayerModal.offsetHeight;
    
    // Activer l'animation avec la classe
    spotifyPlayerModal.classList.add('active');
  });

  // Close Spotify Player Modal
  spotifyCloseButton.addEventListener('click', () => {
    console.log('Closing Spotify Player Modal');
    
    // Retirer la classe pour animer la fermeture
    spotifyPlayerModal.classList.remove('active');
    
    // Nettoyer le lecteur
    cleanupSpotifyPlayer();
    
    // Attendre la fin de l'animation avant de cacher compl√®tement
    setTimeout(() => {
      spotifyPlayerModal.style.display = 'none';
      document.body.style.overflow = '';
    }, 400);
  });

  // Close modal when clicking on backdrop
  document.querySelector('.spotify-modal-backdrop').addEventListener('click', () => {
    spotifyCloseButton.click();
  });

  // Search functionality
  spotifySearchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
      filterReciters(searchTerm);
  });

  // Play/Pause button in the player footer
  document.getElementById('spotify-play').addEventListener('click', toggleSpotifyPlayback);

  // Previous track button
  document.getElementById('spotify-prev').addEventListener('click', playPreviousSurah);

  // Next track button
  document.getElementById('spotify-next').addEventListener('click', playNextSurah);

  // Shuffle button
  spotifyShuffleButton.addEventListener('click', toggleShuffle);
  
  // Repeat button
  spotifyRepeatButton.addEventListener('click', toggleRepeat);
  
  // Like button
  spotifyLikeButton.addEventListener('click', () => {
    if (currentSurahPlaying && currentReciter) {
      addToFavorites(currentSurahPlaying, currentReciter);
    }
  });
  
  // Menu navigation
  spotifyHomeMenu.addEventListener('click', () => switchSpotifySection('home'));
  spotifyFavoritesMenu.addEventListener('click', () => switchSpotifySection('favorites'));
  spotifyPlaylistsMenu.addEventListener('click', () => switchSpotifySection('playlists'));
  spotifyDownloadedMenu.addEventListener('click', () => switchSpotifySection('downloaded'));
  
  // Navigation history buttons
  spotifyNavBack.addEventListener('click', navigateBack);
  spotifyNavForward.addEventListener('click', navigateForward);
  
  // Play all button
  spotifyPlayAllButton.addEventListener('click', () => {
    if (currentReciter && spotifyAllSurahs.length > 0) {
      playSurah(spotifyAllSurahs[0], currentReciter.api_reciter_id);
    }
  });
  
  // Add to favorites button
  spotifyAddToFavoritesButton.addEventListener('click', () => {
    if (currentReciter) {
      // Ajouter le r√©citateur entier aux favoris
      showNotification('Cette fonctionnalit√© sera bient√¥t disponible', 'info');
    }
  });
  
  // Create playlist button
  spotifyCreatePlaylistButton.addEventListener('click', createNewPlaylist);

  // Volume control
  const spotifyVolumeSlider = document.querySelector('.spotify-volume-slider');
  spotifyVolumeSlider.addEventListener('click', (e) => {
    const sliderRect = spotifyVolumeSlider.getBoundingClientRect();
    const clickPosition = e.clientX - sliderRect.left;
    const percentage = (clickPosition / sliderRect.width) * 100;
    
    // Update volume visual
    document.getElementById('spotify-volume-current').style.width = `${percentage}%`;
    
    // Update actual volume
    spotifyAudioElement.volume = percentage / 100;
  });

  // Progress bar control
  const progressBar = document.querySelector('.spotify-progress-bar');
  progressBar.addEventListener('click', (e) => {
    if (!spotifyAudioElement.src) return;
    
    const barRect = progressBar.getBoundingClientRect();
    const clickPosition = e.clientX - barRect.left;
    const percentage = (clickPosition / barRect.width);
    
    // Set current time based on click position
    spotifyAudioElement.currentTime = percentage * spotifyAudioElement.duration;
    
    // Update progress bar visual
    document.getElementById('spotify-progress-current').style.width = `${percentage * 100}%`;
  });

  // Audio player event listeners
  spotifyAudioElement.addEventListener('timeupdate', updateSpotifyProgress);
  spotifyAudioElement.addEventListener('ended', onSpotifyAudioEnded);
  spotifyAudioElement.addEventListener('loadedmetadata', () => {
    const totalTime = formatTime(spotifyAudioElement.duration);
    document.getElementById('spotify-total-time').textContent = totalTime;
  });
  
  // Mini player toggle
  spotifyMiniPlayerToggle.addEventListener('click', () => {
    // Fonctionnalit√© de mini-lecteur √† impl√©menter
    showNotification('Mini-lecteur bient√¥t disponible', 'info');
  });
  
  // Initialiser le gestionnaire de t√©l√©chargements
  if (typeof initDownloadManager === 'function') {
    initDownloadManager();
    console.log('Gestionnaire de t√©l√©chargements initialis√©');
  }
  
  console.log('Spotify player initialized successfully');
}

// Filter reciters based on search input
function filterReciters(searchTerm) {
  if (!allReciters.length) return;
  
  const filteredReciters = allReciters.filter(reciter => 
    reciter.reciter_name.toLowerCase().includes(searchTerm)
  );
  
  renderReciters(filteredReciters);
}

// Select a reciter and load their surahs
function selectReciter(reciter, imgUrl) {
  // Utiliser une image par d√©faut si aucune image n'est fournie
  const safeImgUrl = imgUrl || reciter.image || 'assets/images/reciters/default_reciter.jpg';
  
  // Update selected reciter
  currentReciter = { ...reciter, imgUrl: safeImgUrl };
  
  // Update UI to show active reciter
  const allReciterItems = document.querySelectorAll('.spotify-reciter-item');
  allReciterItems.forEach(item => {
    item.classList.remove('active');
    if (item.dataset.reciterId == reciter.id) {
      item.classList.add('active');
    }
  });
  
  // Update header with reciter info
  document.getElementById('spotify-current-reciter-name').textContent = reciter.reciter_name;
  document.getElementById('spotify-current-reciter-img').src = safeImgUrl;
  
  // Add bio information if available
  const reciterHeaderEl = document.querySelector('.spotify-reciter-header-info');
  if (reciterHeaderEl) {
    // Update subtitle with style
    const subtitleEl = reciterHeaderEl.querySelector('.spotify-reciter-header-subtitle');
    if (subtitleEl) {
      subtitleEl.textContent = reciter.style || 'Style de r√©citation classique';
    }
    
    // Add or update bio element
    let bioEl = reciterHeaderEl.querySelector('.spotify-reciter-bio');
    if (!bioEl && reciter.bio) {
      bioEl = document.createElement('p');
      bioEl.className = 'spotify-reciter-bio';
      reciterHeaderEl.appendChild(bioEl);
    }
    
    if (bioEl) {
      bioEl.textContent = reciter.bio || '';
      bioEl.style.display = reciter.bio ? 'block' : 'none';
    }
  }
  
  // Load all surahs
  return loadAllSurahs(reciter.api_reciter_id);
}

// Load all surahs for the selected reciter
async function loadAllSurahs(reciterId) {
  try {
    // V√©rifier que l'URL de l'API est d√©finie
    if (!QURAN_API_URL) {
      console.error("L'URL de l'API Quran n'est pas d√©finie");
      spotifySurahListElement.innerHTML = `
        <div style="padding: 20px; color: white; text-align: center;">
          <h3>Erreur de configuration</h3>
          <p style="color: #b3b3b3;">L'URL de l'API Quran n'est pas correctement d√©finie.</p>
        </div>
      `;
      return;
    }
    
    spotifySurahListElement.innerHTML = '<div style="padding: 20px; color: white;">Chargement des sourates...</div>';
    
    if (!spotifyAllSurahs.length) {
      // Load surahs from API if not already loaded
      const url = `${QURAN_API_URL}api/v4/chapters?language=fr`;
      console.log("Chargement des sourates depuis:", url);
      
      // Utiliser fetchApi avec retry et timeout au lieu de fetch standard
      const data = await fetchApi(url, { retries: 3, timeout: 30000, context: 'donn√©es API' });
      
      if (!data) {
        throw new Error("√âchec de r√©cup√©ration des donn√©es de l'API");
      }
      
      spotifyAllSurahs = data.chapters;
      console.log(`${spotifyAllSurahs.length} sourates charg√©es avec succ√®s`);
    }
    
    // Render surahs
    renderSurahs(spotifyAllSurahs, reciterId);
  } catch (error) {
    console.error('Erreur lors du chargement des sourates:', error);
    
    // Message d'erreur plus d√©taill√© avec instructions
    spotifySurahListElement.innerHTML = `
      <div style="padding: 20px; color: white; text-align: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="#ff5555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="8" x2="12" y2="12"></line>
          <line x1="12" y1="16" x2="12.01" y2="16"></line>
        </svg>
        <h3 style="margin-top: 15px;">Erreur de chargement des sourates</h3>
        <p style="margin-top: 10px; color: #b3b3b3;">Veuillez v√©rifier votre connexion internet et r√©essayer.</p>
        <button id="retry-load-surahs" style="margin-top: 15px; background: #1DB954; border: none; padding: 8px 16px; color: white; border-radius: 20px; cursor: pointer;">
          R√©essayer
        </button>
      </div>
    `;
    
    // Ajouter un gestionnaire d'√©v√©nements pour le bouton de r√©essai
    const retryButton = document.getElementById('retry-load-surahs');
    if (retryButton) {
      retryButton.addEventListener('click', () => {
        console.log("Tentative de rechargement des sourates...");
        loadAllSurahs(reciterId);
      });
    }
  }
}

// Render surahs in the main content area
function renderSurahs(surahs, reciterId) {
  // Clear previous content
  spotifySurahListElement.innerHTML = '';
  
  surahs.forEach((surah) => {
    // Random duration between 3 and 9 minutes (API doesn't provide durations)
    const minutes = Math.floor(Math.random() * 6) + 3;
    const seconds = Math.floor(Math.random() * 60);
    const duration = `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    
    const surahItem = document.createElement('div');
    surahItem.className = 'spotify-surah-item';
    surahItem.dataset.surahId = surah.id;
    surahItem.dataset.reciterId = reciterId;
    
    // V√©rifier si cette sourate est d√©j√† t√©l√©charg√©e
    const isOffline = checkOfflineAvailability(surah.id);
    
    surahItem.innerHTML = `
      <div class="spotify-surah-number">${surah.id}</div>
      <div>
        <div class="spotify-surah-name">${surah.name_simple}</div>
        <div class="spotify-surah-name-ar">${surah.name_arabic}</div>
      </div>
      <div style="display: flex; justify-content: center; align-items: center;">
        <button class="button dark-single spotify-download-button ${isOffline ? 'downloaded' : ''}" 
          data-surah-id="${surah.id}" 
          data-reciter-id="${reciterId}" 
          title="${isOffline ? 'D√©j√† t√©l√©charg√©e' : 'T√©l√©charger la sourate'}"
          style="width: 32px; height: 32px; border: none;"
          onclick="event.stopPropagation(); event.preventDefault(); return false;">
          <div>
              <svg viewBox="0 0 24 24">
                ${isOffline 
                  ? '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>'
                  : '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>'
                }
          </svg>
          </div>
          <div class="download-progress-container">
            <div class="download-progress-bar"></div>
          </div>
        </button>
      </div>
      <div style="display: flex; justify-content: center; align-items: center; text-align: center;">${duration}</div>
      <button class="spotify-surah-play">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
        </button>
    `;
    
    // --- Ajout du listener d'animation pour CE bouton ---
    const downloadButton = surahItem.querySelector('.spotify-download-button');
    if (downloadButton) {
        downloadButton.addEventListener('click', function(e) {
        e.stopPropagation();
        e.preventDefault();
        
            // Si d√©j√† t√©l√©charg√©, juste montrer une notification
            if (isOffline || downloadButton.classList.contains('downloaded')) {
                console.log('Cette sourate est d√©j√† t√©l√©charg√©e');
                showNotification('Sourate d√©j√† disponible hors ligne', 'info');
                return false;
            }
            
            // Ajouter la classe loading et commencer le t√©l√©chargement
            downloadButton.classList.add('loading');
            
            // Mettre √† jour le SVG pour l'animation de t√©l√©chargement
            const svg = downloadButton.querySelector('svg');
            if (svg) {
                svg.innerHTML = '<path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/>';
            }
            
            // Lancer le t√©l√©chargement
            if (typeof downloadSurahAudio === 'function') {
                const surahId = parseInt(downloadButton.dataset.surahId);
                const reciterId = parseInt(downloadButton.dataset.reciterId);
                
                console.log(`T√©l√©chargement de la sourate ${surahId} (r√©citateur ${reciterId})`);
                
                downloadSurahAudio(surahId, reciterId, downloadButton)
                    .then(() => {
                        // Mise √† jour r√©ussie - mettre √† jour l'ic√¥ne et la classe
                        downloadButton.classList.remove('loading');
                        downloadButton.classList.add('downloaded');
                        if (svg) {
                            svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>';
                        }
                        downloadButton.title = 'T√©l√©chargement termin√©';
                    })
                    .catch(error => {
                        console.error(`Erreur de t√©l√©chargement:`, error);
                        downloadButton.classList.remove('loading');
                        if (svg) {
                            svg.innerHTML = '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
                        }
                        showNotification('Erreur de t√©l√©chargement', 'error');
                    });
            }
            
            return false; // Emp√™cher la propagation
        }, true); // Phase de capture
    }
    
    // Play button click event
    surahItem.querySelector('.spotify-surah-play').addEventListener('click', (e) => {
        e.stopPropagation();
        playSurah(surah, reciterId);
      });
    
    // Entire row click event
    surahItem.addEventListener('click', () => {
      playSurah(surah, reciterId);
    });
    
    spotifySurahListElement.appendChild(surahItem);
  });
}

// Play a surah
async function playSurah(surah, reciterId) {
  try {
    // Update current surah
    currentSurahPlaying = surah;
    
    // Update UI - now playing info
    document.getElementById('spotify-playing-name').textContent = surah.name_simple;
    document.getElementById('spotify-playing-reciter').textContent = currentReciter.reciter_name;
    document.getElementById('spotify-playing-img').src = currentReciter.imgUrl;
    
    // Update play button to loading state
    document.getElementById('spotify-play').innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 6v6l4 2"></path>
      </svg>
    `;
    
    // Afficher un message de chargement √† c√¥t√© du surah
    document.getElementById('spotify-playing-reciter').textContent = `${currentReciter.reciter_name} (Chargement...)`;
    
    // Set audio source - use the API to get the audio file URL
    const audioUrl = `${QURAN_API_URL}api/v4/chapter_recitations/${reciterId}/${surah.id}`;
    console.log(`Chargement de l'audio: ${audioUrl}`);
    
    // Fetch surah audio URL using fetchApi with retry
    const data = await fetchApi(audioUrl, { retries: 3, timeout: 15000, context: 'audio API' });
    
    if (!data) {
      throw new Error("√âchec de r√©cup√©ration des donn√©es audio");
    }
    
    if (data.audio_file && data.audio_file.audio_url) {
      console.log(`Audio URL r√©cup√©r√©e: ${data.audio_file.audio_url}`);
      
      // Remplacer l'√©tat de chargement
      document.getElementById('spotify-playing-reciter').textContent = currentReciter.reciter_name;
      
      // Pr√©charger l'audio
      spotifyAudioElement.src = data.audio_file.audio_url;
      
      // Ajouter un gestionnaire d'√©v√©nements pour le pr√©chargement de l'audio
      const canPlayPromise = new Promise((resolve) => {
        const canPlayHandler = () => {
          console.log("Audio pr√™te √† √™tre jou√©e");
          spotifyAudioElement.removeEventListener('canplay', canPlayHandler);
          resolve();
        };
        
        spotifyAudioElement.addEventListener('canplay', canPlayHandler);
        
        // Timeout pour √©viter de bloquer ind√©finiment si l'audio ne peut pas √™tre pr√©charg√©
        setTimeout(() => {
          spotifyAudioElement.removeEventListener('canplay', canPlayHandler);
          resolve();
        }, 5000);
      });
      
      // Attendre que l'audio soit pr√™te ou que le timeout soit atteint
      await canPlayPromise;
      
      // Jouer l'audio
      try {
        await spotifyAudioElement.play();
        
        // Update play button to pause icon
        document.getElementById('spotify-play').innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
        `;
        
        // Update UI - highlight current surah
        updateCurrentSurahUI(surah.id);
        
        // Ajouter aux r√©cemment jou√©s
        addToRecentlyPlayed(surah, currentReciter);
        
        // Mettre √† jour l'√©tat du bouton like
        updateLikeButtonState();
      } catch (playError) {
        console.error('Erreur lors de la lecture:', playError);
        handleAudioError();
      }
    } else {
      console.error('URL audio non trouv√©e pour la sourate:', surah.id);
      handleAudioError();
        }
      } catch (error) {
    console.error('Erreur lors de la lecture de la sourate:', error);
    handleAudioError();
  }
}

// Ajouter aux r√©cemment jou√©s
function addToRecentlyPlayed(surah, reciter) {
  // V√©rifier si l'√©l√©ment existe d√©j√† dans les r√©cemment jou√©s
  const existingIndex = spotifyRecentlyPlayed.findIndex(item => 
    item.surahId === surah.id && item.reciterId === reciter.id
  );
  
  // Si l'√©l√©ment existe d√©j√†, le supprimer
  if (existingIndex !== -1) {
    spotifyRecentlyPlayed.splice(existingIndex, 1);
  }
  
  // S'assurer que l'URL de l'image est valide
  const reciterImgUrl = reciter.image || reciter.imgUrl || 'assets/images/reciters/default_reciter.jpg';
  
  // Ajouter le nouvel √©l√©ment au d√©but
  const recentItem = {
    surahId: surah.id,
    surahName: surah.name_simple,
    reciterId: reciter.id,
    reciterName: reciter.reciter_name,
    apiReciterId: reciter.api_reciter_id,
    reciterImgUrl: reciterImgUrl,
    timestamp: Date.now()
  };
  
  spotifyRecentlyPlayed.unshift(recentItem);
  
  // Limiter √† 20 √©l√©ments
  if (spotifyRecentlyPlayed.length > 20) {
    spotifyRecentlyPlayed = spotifyRecentlyPlayed.slice(0, 20);
  }
  
  // Sauvegarder dans le stockage local
  localStorage.setItem('spotifyRecentlyPlayed', JSON.stringify(spotifyRecentlyPlayed));
  
  // Mettre √† jour l'affichage si visible
  if (spotifyHomeSection && !spotifyHomeSection.classList.contains('hidden')) {
    loadRecentlyPlayed();
  }
}

// Lecture de la sourate suivante avec gestion du shuffle et repeat
function playNextSurah() {
  if (!currentSurahPlaying || !spotifyAllSurahs.length) return;
  
  let nextSurah;
  const currentIndex = spotifyAllSurahs.findIndex(s => s.id === currentSurahPlaying.id);
  
  if (isShuffleActive) {
    // Mode al√©atoire - choisir une sourate au hasard (diff√©rente de la courante)
    let randomIndex;
    do {
      randomIndex = Math.floor(Math.random() * spotifyAllSurahs.length);
    } while (randomIndex === currentIndex && spotifyAllSurahs.length > 1);
    
    nextSurah = spotifyAllSurahs[randomIndex];
  } else {
    // Mode normal - sourate suivante
    if (currentIndex < spotifyAllSurahs.length - 1) {
      nextSurah = spotifyAllSurahs[currentIndex + 1];
    } else if (repeatMode === 'all') {
      // En mode repeat all, revenir √† la premi√®re sourate
      nextSurah = spotifyAllSurahs[0];
    } else {
      return; // Fin de la liste et pas de repeat
    }
  }
  
  if (nextSurah) {
    playSurah(nextSurah, currentReciter.api_reciter_id);
  }
}

// Lecture de la sourate pr√©c√©dente
function playPreviousSurah() {
  if (!currentSurahPlaying || !spotifyAllSurahs.length) return;
  
  const currentIndex = spotifyAllSurahs.findIndex(s => s.id === currentSurahPlaying.id);
  let prevSurah;
  
  if (isShuffleActive) {
    // En mode al√©atoire, aller √† une sourate au hasard (ou au d√©but de la sourate actuelle si < 3s)
    if (spotifyAudioElement.currentTime < 3) {
      let randomIndex;
      do {
        randomIndex = Math.floor(Math.random() * spotifyAllSurahs.length);
      } while (randomIndex === currentIndex && spotifyAllSurahs.length > 1);
      
      prevSurah = spotifyAllSurahs[randomIndex];
    } else {
      // Revenir au d√©but de la sourate actuelle
      spotifyAudioElement.currentTime = 0;
      return;
    }
  } else {
    // Mode normal
    if (spotifyAudioElement.currentTime > 3) {
      // Si on est au-del√† de 3 secondes, revenir au d√©but de la sourate
      spotifyAudioElement.currentTime = 0;
      return;
    } else if (currentIndex > 0) {
      // Sinon, aller √† la sourate pr√©c√©dente
      prevSurah = spotifyAllSurahs[currentIndex - 1];
    } else if (repeatMode === 'all') {
      // En mode repeat all, aller √† la derni√®re sourate
      prevSurah = spotifyAllSurahs[spotifyAllSurahs.length - 1];
    }
  }
  
  if (prevSurah) {
    playSurah(prevSurah, currentReciter.api_reciter_id);
  }
}

// Gestion de la fin de la lecture audio
function onSpotifyAudioEnded() {
  // V√©rifier le mode repeat
  if (repeatMode === 'one') {
    // Rejouer la m√™me sourate
    spotifyAudioElement.currentTime = 0;
    spotifyAudioElement.play();
  } else {
    // Passer √† la sourate suivante (avec gestion du shuffle et repeat all)
    playNextSurah();
  }
}

// Toggle shuffle mode
function toggleShuffle() {
  isShuffleActive = !isShuffleActive;
  
  // Mise √† jour visuelle
  if (isShuffleActive) {
    spotifyShuffleButton.classList.add('active');
    showNotification('Lecture al√©atoire activ√©e', 'info');
  } else {
    spotifyShuffleButton.classList.remove('active');
    showNotification('Lecture al√©atoire d√©sactiv√©e', 'info');
  }
}

// Toggle repeat mode
function toggleRepeat() {
  // Cycle between: none -> all -> one -> none
  switch (repeatMode) {
    case 'none':
      repeatMode = 'all';
      spotifyRepeatButton.classList.add('active');
      spotifyRepeatButton.classList.remove('repeat-one');
      showNotification('R√©p√©ter toutes les sourates', 'info');
      break;
    case 'all':
      repeatMode = 'one';
      spotifyRepeatButton.classList.add('active');
      spotifyRepeatButton.classList.add('repeat-one');
      showNotification('R√©p√©ter la sourate', 'info');
      break;
    case 'one':
      repeatMode = 'none';
      spotifyRepeatButton.classList.remove('active');
      spotifyRepeatButton.classList.remove('repeat-one');
      showNotification('R√©p√©tition d√©sactiv√©e', 'info');
      break;
  }
}

// Initialize Spotify Player
function initSpotifyPlayer() {
  if (!spotifyPlayerModal || !spotifyPlayerButton || !spotifyCloseButton) {
    console.error('Spotify player elements not found in DOM');
    return;
  }

  // Open Spotify Player Modal
  spotifyPlayerButton.addEventListener('click', () => {
    console.log('Opening Spotify Player Modal');
    
    // Pr√©parer l'animation
    document.body.style.overflow = 'hidden';
    spotifyPlayerModal.style.display = 'flex';
    
    // Load reciters if not already loaded
    if (spotifyRecitersListElement.children.length === 0) {
      loadReciters().then(() => {
        // Automatically select the first reciter when reciters are loaded
        if (allReciters.length > 0) {
          const firstReciter = allReciters[0];
          const imageUrl = firstReciter.image || 'assets/images/reciters/default_reciter.jpg';
          selectReciter(firstReciter, imageUrl);
        }
      });
    } else if (allReciters.length > 0 && !currentReciter) {
      // If reciters are already loaded but none is selected, select the first one
      const firstReciter = allReciters[0];
      const imageUrl = firstReciter.image || 'assets/images/reciters/default_reciter.jpg';
      selectReciter(firstReciter, imageUrl);
    }
    
    // Charger les r√©cemment √©cout√©s
    spotifyRecentlyPlayed = JSON.parse(localStorage.getItem('spotifyRecentlyPlayed') || '[]');
    loadRecentlyPlayed();
    
    // Par d√©faut, afficher la section d'accueil
    switchSpotifySection('home');
    
    // Initialiser l'historique de navigation
    if (spotifyNavHistory.length === 0) {
      spotifyNavHistory = ['home'];
      spotifyNavPosition = 0;
    }
    
    // Forcer le reflow pour que la transition fonctionne
    spotifyPlayerModal.offsetHeight;
    
    // Activer l'animation avec la classe
    spotifyPlayerModal.classList.add('active');
  });

  // Close Spotify Player Modal
  spotifyCloseButton.addEventListener('click', () => {
    console.log('Closing Spotify Player Modal');
    
    // Retirer la classe pour animer la fermeture
    spotifyPlayerModal.classList.remove('active');
    
    // Nettoyer le lecteur
    cleanupSpotifyPlayer();
    
    // Attendre la fin de l'animation avant de cacher compl√®tement
    setTimeout(() => {
      spotifyPlayerModal.style.display = 'none';
      document.body.style.overflow = '';
    }, 400);
  });

  // Close modal when clicking on backdrop
  document.querySelector('.spotify-modal-backdrop').addEventListener('click', () => {
    spotifyCloseButton.click();
  });

  // Search functionality
  spotifySearchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    filterReciters(searchTerm);
  });

  // Play/Pause button in the player footer
  document.getElementById('spotify-play').addEventListener('click', toggleSpotifyPlayback);

  // Previous track button
  document.getElementById('spotify-prev').addEventListener('click', playPreviousSurah);

  // Next track button
  document.getElementById('spotify-next').addEventListener('click', playNextSurah);

  // Shuffle button
  spotifyShuffleButton.addEventListener('click', toggleShuffle);
  
  // Repeat button
  spotifyRepeatButton.addEventListener('click', toggleRepeat);
  
  // Like button
  spotifyLikeButton.addEventListener('click', () => {
    if (currentSurahPlaying && currentReciter) {
      addToFavorites(currentSurahPlaying, currentReciter);
    }
  });
  
  // Menu navigation
  spotifyHomeMenu.addEventListener('click', () => switchSpotifySection('home'));
  spotifyFavoritesMenu.addEventListener('click', () => switchSpotifySection('favorites'));
  spotifyPlaylistsMenu.addEventListener('click', () => switchSpotifySection('playlists'));
  spotifyDownloadedMenu.addEventListener('click', () => switchSpotifySection('downloaded'));
  
  // Navigation history buttons
  spotifyNavBack.addEventListener('click', navigateBack);
  spotifyNavForward.addEventListener('click', navigateForward);
  
  // Play all button
  spotifyPlayAllButton.addEventListener('click', () => {
    if (currentReciter && spotifyAllSurahs.length > 0) {
      playSurah(spotifyAllSurahs[0], currentReciter.api_reciter_id);
    }
  });
  
  // Add to favorites button
  spotifyAddToFavoritesButton.addEventListener('click', () => {
    if (currentReciter) {
      // Ajouter le r√©citateur entier aux favoris
      showNotification('Cette fonctionnalit√© sera bient√¥t disponible', 'info');
    }
  });
  
  // Create playlist button
  spotifyCreatePlaylistButton.addEventListener('click', createNewPlaylist);

  // Volume control
  const spotifyVolumeSlider = document.querySelector('.spotify-volume-slider');
  spotifyVolumeSlider.addEventListener('click', (e) => {
    const sliderRect = spotifyVolumeSlider.getBoundingClientRect();
    const clickPosition = e.clientX - sliderRect.left;
    const percentage = (clickPosition / sliderRect.width) * 100;
    
    // Update volume visual
    document.getElementById('spotify-volume-current').style.width = `${percentage}%`;
    
    // Update actual volume
    spotifyAudioElement.volume = percentage / 100;
  });

  // Progress bar control
  const progressBar = document.querySelector('.spotify-progress-bar');
  progressBar.addEventListener('click', (e) => {
    if (!spotifyAudioElement.src) return;
    
    const barRect = progressBar.getBoundingClientRect();
    const clickPosition = e.clientX - barRect.left;
    const percentage = (clickPosition / barRect.width);
    
    // Set current time based on click position
    spotifyAudioElement.currentTime = percentage * spotifyAudioElement.duration;
    
    // Update progress bar visual
    document.getElementById('spotify-progress-current').style.width = `${percentage * 100}%`;
  });

  // Audio player event listeners
  spotifyAudioElement.addEventListener('timeupdate', updateSpotifyProgress);
  spotifyAudioElement.addEventListener('ended', onSpotifyAudioEnded);
  spotifyAudioElement.addEventListener('loadedmetadata', () => {
    const totalTime = formatTime(spotifyAudioElement.duration);
    document.getElementById('spotify-total-time').textContent = totalTime;
  });
  
  // Mini player toggle
  spotifyMiniPlayerToggle.addEventListener('click', () => {
    // Fonctionnalit√© de mini-lecteur √† impl√©menter
    showNotification('Mini-lecteur bient√¥t disponible', 'info');
  });
  
  // Initialiser le gestionnaire de t√©l√©chargements
  if (typeof initDownloadManager === 'function') {
    initDownloadManager();
    console.log('Gestionnaire de t√©l√©chargements initialis√©');
  }
  
  console.log('Spotify player initialized successfully');
}

// Filter reciters based on search input
function filterReciters(searchTerm) {
  if (!allReciters.length) return;
  
  const filteredReciters = allReciters.filter(reciter => 
    reciter.reciter_name.toLowerCase().includes(searchTerm)
  );
  
  renderReciters(filteredReciters);
}

// Select a reciter and load their surahs
function selectReciter(reciter, imgUrl) {
  // Utiliser une image par d√©faut si aucune image n'est fournie
  const safeImgUrl = imgUrl || reciter.image || 'assets/images/reciters/default_reciter.jpg';
  
  // Update selected reciter
  currentReciter = { ...reciter, imgUrl: safeImgUrl };
  
  // Update UI to show active reciter
  const allReciterItems = document.querySelectorAll('.spotify-reciter-item');
  allReciterItems.forEach(item => {
    item.classList.remove('active');
    if (item.dataset.reciterId == reciter.id) {
      item.classList.add('active');
    }
  });
  
  // Update header with reciter info
  document.getElementById('spotify-current-reciter-name').textContent = reciter.reciter_name;
  document.getElementById('spotify-current-reciter-img').src = safeImgUrl;
  
  // Add bio information if available
  const reciterHeaderEl = document.querySelector('.spotify-reciter-header-info');
  if (reciterHeaderEl) {
    // Update subtitle with style
    const subtitleEl = reciterHeaderEl.querySelector('.spotify-reciter-header-subtitle');
    if (subtitleEl) {
      subtitleEl.textContent = reciter.style || 'Style de r√©citation classique';
    }
    
    // Add or update bio element
    let bioEl = reciterHeaderEl.querySelector('.spotify-reciter-bio');
    if (!bioEl && reciter.bio) {
      bioEl = document.createElement('p');
      bioEl.className = 'spotify-reciter-bio';
      reciterHeaderEl.appendChild(bioEl);
    }
    
    if (bioEl) {
      bioEl.textContent = reciter.bio || '';
      bioEl.style.display = reciter.bio ? 'block' : 'none';
    }
  }
  
  // Load all surahs
  return loadAllSurahs(reciter.api_reciter_id);
}

// Load all surahs for the selected reciter
async function loadAllSurahs(reciterId) {
  try {
    // V√©rifier que l'URL de l'API est d√©finie
    if (!QURAN_API_URL) {
      console.error("L'URL de l'API Quran n'est pas d√©finie");
      spotifySurahListElement.innerHTML = `
        <div style="padding: 20px; color: white; text-align: center;">
          <h3>Erreur de configuration</h3>
          <p style="color: #b3b3b3;">L'URL de l'API Quran n'est pas correctement d√©finie.</p>
        </div>
      `;
      return;
    }
    
    spotifySurahListElement.innerHTML = '<div style="padding: 20px; color: white;">Chargement des sourates...</div>';
    
    if (!spotifyAllSurahs.length) {
      // Load surahs from API if not already loaded
      const url = `${QURAN_API_URL}api/v4/chapters?language=fr`;
      console.log("Chargement des sourates depuis:", url);
      
      // Utiliser fetchApi avec retry et timeout au lieu de fetch standard
      const data = await fetchApi(url, { retries: 3, timeout: 30000, context: 'donn√©es API' });
      
      if (!data) {
        throw new Error("√âchec de r√©cup√©ration des donn√©es de l'API");
      }
      
      spotifyAllSurahs = data.chapters;
      console.log(`${spotifyAllSurahs.length} sourates charg√©es avec succ√®s`);
    }
    
    // Render surahs
    renderSurahs(spotifyAllSurahs, reciterId);
  } catch (error) {
    console.error('Erreur lors du chargement des sourates:', error);
    
    // Message d'erreur plus d√©taill√© avec instructions
    spotifySurahListElement.innerHTML = `
      <div style="padding: 20px; color: white; text-align: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="#ff5555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="8" x2="12" y2="12"></line>
          <line x1="12" y1="16" x2="12.01" y2="16"></line>
        </svg>
        <h3 style="margin-top: 15px;">Erreur de chargement des sourates</h3>
        <p style="margin-top: 10px; color: #b3b3b3;">Veuillez v√©rifier votre connexion internet et r√©essayer.</p>
        <button id="retry-load-surahs" style="margin-top: 15px; background: #1DB954; border: none; padding: 8px 16px; color: white; border-radius: 20px; cursor: pointer;">
          R√©essayer
        </button>
      </div>
    `;
    
    // Ajouter un gestionnaire d'√©v√©nements pour le bouton de r√©essai
    const retryButton = document.getElementById('retry-load-surahs');
    if (retryButton) {
      retryButton.addEventListener('click', () => {
        console.log("Tentative de rechargement des sourates...");
        loadAllSurahs(reciterId);
      });
    }
  }
}

// Render surahs in the main content area
function renderSurahs(surahs, reciterId) {
  // Clear previous content
  spotifySurahListElement.innerHTML = '';
  
  surahs.forEach((surah) => {
    // Random duration between 3 and 9 minutes (API doesn't provide durations)
    const minutes = Math.floor(Math.random() * 6) + 3;
    const seconds = Math.floor(Math.random() * 60);
    const duration = `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    
    const surahItem = document.createElement('div');
    surahItem.className = 'spotify-surah-item';
    surahItem.dataset.surahId = surah.id;
    surahItem.dataset.reciterId = reciterId;
    
    // V√©rifier si cette sourate est d√©j√† t√©l√©charg√©e
    const isOffline = checkOfflineAvailability(surah.id);
    
    surahItem.innerHTML = `
      <div class="spotify-surah-number">${surah.id}</div>
      <div>
        <div class="spotify-surah-name">${surah.name_simple}</div>
        <div class="spotify-surah-name-ar">${surah.name_arabic}</div>
      </div>
      <div style="display: flex; justify-content: center; align-items: center;">
        <button class="button dark-single spotify-download-button ${isOffline ? 'downloaded' : ''}" 
          data-surah-id="${surah.id}" 
          data-reciter-id="${reciterId}" 
          title="${isOffline ? 'D√©j√† t√©l√©charg√©e' : 'T√©l√©charger la sourate'}"
          style="width: 32px; height: 32px; border: none;"
          onclick="event.stopPropagation(); event.preventDefault(); return false;">
          <div>
              <svg viewBox="0 0 24 24">
                ${isOffline 
                  ? '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>'
                  : '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>'
                }
          </svg>
          </div>
          <div class="download-progress-container">
            <div class="download-progress-bar"></div>
          </div>
        </button>
      </div>
      <div style="display: flex; justify-content: center; align-items: center; text-align: center;">${duration}</div>
      <button class="spotify-surah-play">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
        </button>
    `;
    
    // --- Ajout du listener d'animation pour CE bouton ---
    const downloadButton = surahItem.querySelector('.spotify-download-button');
    if (downloadButton) {
        downloadButton.addEventListener('click', function(e) {
        e.stopPropagation();
        e.preventDefault();
        
            // Si d√©j√† t√©l√©charg√©, juste montrer une notification
            if (isOffline || downloadButton.classList.contains('downloaded')) {
                console.log('Cette sourate est d√©j√† t√©l√©charg√©e');
                showNotification('Sourate d√©j√† disponible hors ligne', 'info');
                return false;
            }
            
            // Ajouter la classe loading et commencer le t√©l√©chargement
            downloadButton.classList.add('loading');
            
            // Mettre √† jour le SVG pour l'animation de t√©l√©chargement
            const svg = downloadButton.querySelector('svg');
            if (svg) {
                svg.innerHTML = '<path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/>';
            }
            
            // Lancer le t√©l√©chargement
            if (typeof downloadSurahAudio === 'function') {
                const surahId = parseInt(downloadButton.dataset.surahId);
                const reciterId = parseInt(downloadButton.dataset.reciterId);
                
                console.log(`T√©l√©chargement de la sourate ${surahId} (r√©citateur ${reciterId})`);
                
                downloadSurahAudio(surahId, reciterId, downloadButton)
                    .then(() => {
                        // Mise √† jour r√©ussie - mettre √† jour l'ic√¥ne et la classe
                        downloadButton.classList.remove('loading');
                        downloadButton.classList.add('downloaded');
                        if (svg) {
                            svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>';
                        }
                        downloadButton.title = 'T√©l√©chargement termin√©';
                    })
                    .catch(error => {
                        console.error(`Erreur de t√©l√©chargement:`, error);
                        downloadButton.classList.remove('loading');
                        if (svg) {
                            svg.innerHTML = '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
                        }
                        showNotification('Erreur de t√©l√©chargement', 'error');
                    });
            }
            
            return false; // Emp√™cher la propagation
        }, true); // Phase de capture
    }
    
    // Play button click event
    surahItem.querySelector('.spotify-surah-play').addEventListener('click', (e) => {
        e.stopPropagation();
        playSurah(surah, reciterId);
      });
    
    // Entire row click event
    surahItem.addEventListener('click', () => {
      playSurah(surah, reciterId);
    });
    
    spotifySurahListElement.appendChild(surahItem);
  });
}

// --- Fonctions JS pour l'animation du bouton ---
function getPoint(point, i, a, smoothing) {
    let cp = (current, previous, next, reverse) => {
            let p = previous || current,
                n = next || current,
                o = {
                    length: Math.sqrt(Math.pow(n[0] - p[0], 2) + Math.pow(n[1] - p[1], 2)),
                    angle: Math.atan2(n[1] - p[1], n[0] - p[0])
                },
                angle = o.angle + (reverse ? Math.PI : 0),
                length = o.length * smoothing;
            return [current[0] + Math.cos(angle) * length, current[1] + Math.sin(angle) * length];
        },
        cps = cp(a[i - 1], a[i - 2], point, false),
        cpe = cp(point, a[i - 1], a[i + 1], true);
    return `C ${cps[0]},${cps[1]} ${cpe[0]},${cpe[1]} ${point[0]},${point[1]}`;
}

function getPath(update, smoothing, pointsNew) {
    // Points originaux du JS fourni, semblent pour une viewBox 20x20 ou similaire.
    let points = pointsNew ? pointsNew : [
            [4, 12],
            [12, update], // y-coordinate for animation
            [20, 12]
        ];
     // Si les points checkmark sont aussi du JS:
     if (pointsNew && pointsNew.length === 3 && pointsNew[0][0] === 3) { // D√©tection heuristique du checkmark
         points = [ // Points checkmark du JS original
             [3, 14],
             [8, 19],
             [21, 6]
         ];
     } else if (!pointsNew) { // Fl√®che initiale simple
         points = [
             [6, 10],
             [12, 16],
             [18, 10]
         ];
     }

    let d = points.reduce((acc, point, i, a) => i === 0 ? `M ${point[0]},${point[1]}` : `${acc} ${getPoint(point, i, a, smoothing)}`, '');
    return `<path d="${d}" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" />`; // Assurer les attributs SVG + fallback arrow color
}

function setupDownloadButtonAnimation(button) {
    if (typeof gsap === 'undefined') {
        console.warn("GSAP non charg√©. Animation d√©sactiv√©e.");
        const svg = button.querySelector('svg');
        if (svg) {
             // Ic√¥ne statique de t√©l√©chargement (fl√®che simple)
             svg.innerHTML = '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
        }
        button.addEventListener('click', e => {
            e.preventDefault();
            console.log('T√©l√©chargement cliqu√© (sans anim)', button.dataset.surahId);
            // ICI : Logique de t√©l√©chargement r√©elle
             button.innerHTML = '<div><svg viewBox="0 0 24 24"><path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/></svg></div>'; // Indicate download started
             setTimeout(() => { // Simulate completion
                svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>'; // Static checkmark
             }, 1500);
        });
      return;
    }

    let duration = 3000,
        svg = button.querySelector('svg'),
        svgPath = new Proxy({ y: null, smoothing: null }, {
            set(target, key, value) {
                target[key] = value;
                if(target.y !== null && target.smoothing !== null) {
                    svg.innerHTML = getPath(target.y, target.smoothing, null); // Utilise la fonction getPath ajust√©e
                }
                return true;
            },
            get(target, key) { return target[key]; }
        });

    button.style.setProperty('--duration', duration);

    // Initialiser avec la fl√®che statique via getPath
    svg.innerHTML = getPath(16, 0); // y=16 correspond √† la fl√®che dans notre logique getPath

    button.addEventListener('click', e => {
        e.preventDefault();
        if(!button.classList.contains('loading')) {
            button.classList.add('loading');

            // Animation de la fl√®che (si getPath/Proxy la g√®re)
            gsap.to(svgPath, { smoothing: .3, duration: duration * .065 / 1000 });
            gsap.to(svgPath, { y: 12, duration: duration * .265 / 1000, delay: duration * .065 / 1000, ease: Elastic.easeOut.config(1.12, .4) });

            // Afficher le checkmark √† mi-chemin
            setTimeout(() => {
                if (button.classList.contains('loading')) {
                   // Points Checkmark du JS original : [[3, 14], [8, 19], [21, 6]]
                   // On les passe √† getPath pour qu'il les utilise
                   svg.innerHTML = getPath(0, 0, [[3, 14], [8, 19], [21, 6]]);
                }
            }, duration / 2);

             // R√©initialiser apr√®s l'animation
             setTimeout(() => {
                 button.classList.remove('loading');
                 // Remettre la fl√®che initiale via getPath
                 svg.innerHTML = getPath(16, 0); // Assuming y=16 is the arrow
             }, duration); // Fin de l'animation principale

             console.log('T√©l√©chargement initi√© (avec anim)', button.dataset.surahId);
             // ICI : Logique de t√©l√©chargement r√©elle
             // Ex: downloadSurahAudio(button.dataset.surahId, button.dataset.reciterId);
        } else {
          console.log('T√©l√©chargement d√©j√† en cours ou termin√© ?'); // Log si d√©j√† 'loading'
        }
    });

// ... rest of setupDownloadButtonAnimation function (GSAP check fallback) ...

// Handle the case without GSAP as well
    if (typeof gsap === 'undefined') {
        // Remove previous fallback listener if it exists
        if (button._clickFallbackHandler) {
            button.removeEventListener('click', button._clickFallbackHandler);
        }
        // Define the new fallback handler
        button._clickFallbackHandler = (e) => {
            e.preventDefault();
            e.stopPropagation(); // <<<< AJOUT√â ICI
            console.log('T√©l√©chargement cliqu√© (sans anim)', button.dataset.surahId);
            // ICI : Logique de t√©l√©chargement r√©elle
             const svg = button.querySelector('svg');
             if (svg) {
                svg.innerHTML = '<path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/>'; // Indicate download started
             }
             setTimeout(() => { // Simulate completion
                if (svg) {
                  svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>'; // Static checkmark
                }
             }, 1500);
        };
        // Add the new fallback listener
        button.addEventListener('click', button._clickFallbackHandler);
    } else {
        // The GSAP listener already has stopPropagation from the previous edit
        button.addEventListener('click', e => {
            e.preventDefault();
            e.stopPropagation(); // This should already be here
            // ... rest of the GSAP click handler ...
             if(!button.classList.contains('loading')) {
                 button.classList.add('loading');
                 // ... GSAP animations ...
                 setTimeout(() => { /* show checkmark */ }, duration / 2);
                 setTimeout(() => { /* reset button */ }, duration);
                 console.log('T√©l√©chargement initi√© (avec anim)', button.dataset.surahId);
                 // ICI : Logique de t√©l√©chargement r√©elle
             } else {
               console.log('T√©l√©chargement d√©j√† en cours ou termin√© ?');
             }
        });
    }
}
// --- Fin fonctions JS ---

// ... (Ensure these functions are defined before they are called, e.g., before initApp)


// Update the UI to highlight the current playing surah
function updateCurrentSurahUI(surahId) {
  const allSurahItems = document.querySelectorAll('.spotify-surah-item');
  allSurahItems.forEach(item => {
    item.style.backgroundColor = '';
    if (item.dataset.surahId == surahId) {
      item.style.backgroundColor = 'rgba(30, 215, 96, 0.2)';
    }
  });
}

// Update progress bar and time display during playback
function updateSpotifyProgress() {
  if (!spotifyAudioElement.duration) return;
  
  const currentTime = spotifyAudioElement.currentTime;
  const duration = spotifyAudioElement.duration;
  const progressPercentage = (currentTime / duration) * 100;
  
  // Update progress bar
  document.getElementById('spotify-progress-current').style.width = `${progressPercentage}%`;
  
  // Update time display
  document.getElementById('spotify-current-time').textContent = formatTime(currentTime);
  document.getElementById('spotify-total-time').textContent = formatTime(duration);
}

// Format time in MM:SS format
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs < 10 ? '0' + secs : secs}`;
}

// Toggle play/pause functionality
function toggleSpotifyPlayback() {
  if (!spotifyAudioElement.src) {
    console.log('No audio source available');
    return;
  }
  
  if (spotifyAudioElement.paused) {
    spotifyAudioElement.play();
    // Update play button to pause icon
    document.getElementById('spotify-play').innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
    `;
  } else {
    spotifyAudioElement.pause();
    // Update pause button to play icon
    document.getElementById('spotify-play').innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    `;
  }
}

// Handle audio ended event
function onSpotifyAudioEnded() {
  // Play next surah when current one finishes
  playNextSurah();
}

// Play the previous surah
function playPreviousSurah() {
  if (!currentSurahPlaying || !spotifyAllSurahs.length) return;
  
  const currentIndex = spotifyAllSurahs.findIndex(s => s.id === currentSurahPlaying.id);
  if (currentIndex > 0) {
    const previousSurah = spotifyAllSurahs[currentIndex - 1];
    playSurah(previousSurah, currentReciter.api_reciter_id);
  }
}

// Play the next surah
function playNextSurah() {
  if (!currentSurahPlaying || !spotifyAllSurahs.length) return;
  
  const currentIndex = spotifyAllSurahs.findIndex(s => s.id === currentSurahPlaying.id);
  if (currentIndex < spotifyAllSurahs.length - 1) {
    const nextSurah = spotifyAllSurahs[currentIndex + 1];
    playSurah(nextSurah, currentReciter.api_reciter_id);
  }
}

// Initialize the Spotify player when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
  initSpotifyPlayer();
});

// Handle audio error
function handleAudioError() {
  // Reset play button
  document.getElementById('spotify-play').innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polygon points="5 3 19 12 5 21 5 3"></polygon>
    </svg>
  `;
  
  // Afficher un message d'erreur
  document.getElementById('spotify-playing-reciter').textContent = 
    `${currentReciter ? currentReciter.reciter_name : 'R√©citateur'} (Audio indisponible)`;
  
  // Afficher une notification d'erreur
  showNotification('Audio indisponible', 'Veuillez essayer un autre r√©citateur ou une autre sourate');
}

// Try to load audio from alternative source
async function tryAlternativeAudioSource() {
  if (!currentSurahPlaying) return;
  
  // Instead of trying Mishary Rashid Alafasy as a fallback, just show an error message
  console.log(`Audio non disponible pour cette sourate`);
  
  // Mettre √† jour l'affichage pour montrer que l'audio n'est pas disponible
  document.getElementById('spotify-playing-reciter').textContent = 
    `${currentReciter ? currentReciter.reciter_name : 'R√©citateur'} (Audio indisponible)`;
  
  // Afficher une notification d'erreur
  showNotification('Audio indisponible', 'Veuillez essayer un autre r√©citateur ou une autre sourate');
  
  // R√©initialiser le bouton de lecture
  document.getElementById('spotify-play').innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polygon points="5 3 19 12 5 21 5 3"></polygon>
    </svg>
  `;
}

// Update the UI to highlight the current playing surah
function updateCurrentSurahUI(surahId) {
  const allSurahItems = document.querySelectorAll('.spotify-surah-item');
  allSurahItems.forEach(item => {
    item.style.backgroundColor = '';
    if (item.dataset.surahId == surahId) {
      item.style.backgroundColor = 'rgba(30, 215, 96, 0.2)';
    }
  });
}

// Update progress bar and time display during playback
function updateSpotifyProgress() {
  if (!spotifyAudioElement.duration) return;
  
  const currentTime = spotifyAudioElement.currentTime;
  const duration = spotifyAudioElement.duration;
  const progressPercentage = (currentTime / duration) * 100;
  
  // Update progress bar
  document.getElementById('spotify-progress-current').style.width = `${progressPercentage}%`;
  
  // Update time display
  document.getElementById('spotify-current-time').textContent = formatTime(currentTime);
  document.getElementById('spotify-total-time').textContent = formatTime(duration);
}

// Format time in MM:SS format
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs < 10 ? '0' + secs : secs}`;
}

// Toggle play/pause functionality
function toggleSpotifyPlayback() {
  if (!spotifyAudioElement.src) {
    console.log('No audio source available');
    return;
  }
  
  if (spotifyAudioElement.paused) {
    spotifyAudioElement.play();
    // Update play button to pause icon
    document.getElementById('spotify-play').innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
    `;
  } else {
    spotifyAudioElement.pause();
    // Update pause button to play icon
    document.getElementById('spotify-play').innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
          <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </svg>
    `;
  }
}

// Handle audio ended event
function onSpotifyAudioEnded() {
  // Play next surah when current one finishes
  playNextSurah();
}

// Play the previous surah
function playPreviousSurah() {
  if (!currentSurahPlaying || !spotifyAllSurahs.length) return;
  
  const currentIndex = spotifyAllSurahs.findIndex(s => s.id === currentSurahPlaying.id);
  if (currentIndex > 0) {
    const previousSurah = spotifyAllSurahs[currentIndex - 1];
    playSurah(previousSurah, currentReciter.api_reciter_id);
  }
}

// Fonctions de gestion de la navigation et des sections
function switchSpotifySection(sectionId) {
  // Masquer toutes les sections
  spotifyHomeSection.classList.add('hidden');
  spotifyFavoritesSection.classList.add('hidden');
  spotifyPlaylistsSection.classList.add('hidden');
  spotifyDownloadedSection.classList.add('hidden');
  
  // D√©sactiver tous les items du menu
  spotifyHomeMenu.classList.remove('active');
  spotifyFavoritesMenu.classList.remove('active');
  spotifyPlaylistsMenu.classList.remove('active');
  spotifyDownloadedMenu.classList.remove('active');
  
  // Afficher la section demand√©e et activer l'item du menu correspondant
  switch(sectionId) {
    case 'home':
      spotifyHomeSection.classList.remove('hidden');
      spotifyHomeMenu.classList.add('active');
      break;
    case 'favorites':
      spotifyFavoritesSection.classList.remove('hidden');
      spotifyFavoritesMenu.classList.add('active');
      loadFavorites();
      break;
    case 'playlists':
      spotifyPlaylistsSection.classList.remove('hidden');
      spotifyPlaylistsMenu.classList.add('active');
      loadPlaylists();
      break;
    case 'downloaded':
      spotifyDownloadedSection.classList.remove('hidden');
      spotifyDownloadedMenu.classList.add('active');
      loadDownloaded();
            break;
          }
  
  // Ajouter √† l'historique de navigation si ce n'est pas une navigation via les boutons pr√©c√©dent/suivant
  if (!isNavigating) {
    // Supprimer tout ce qui est apr√®s la position actuelle
    if (spotifyNavPosition < spotifyNavHistory.length - 1) {
      spotifyNavHistory = spotifyNavHistory.slice(0, spotifyNavPosition + 1);
    }
    
    // Ajouter la nouvelle section
    spotifyNavHistory.push(sectionId);
    spotifyNavPosition = spotifyNavHistory.length - 1;
  }
  
  // Mettre √† jour l'√©tat des boutons de navigation
  updateNavButtons();
}

// Mettre √† jour l'√©tat des boutons de navigation
function updateNavButtons() {
  spotifyNavBack.disabled = spotifyNavPosition <= 0;
  spotifyNavForward.disabled = spotifyNavPosition >= spotifyNavHistory.length - 1;
  
  // Mise √† jour visuelle
  if (spotifyNavBack.disabled) {
    spotifyNavBack.style.opacity = 0.5;
    spotifyNavBack.style.cursor = 'default';
  } else {
    spotifyNavBack.style.opacity = 1;
    spotifyNavBack.style.cursor = 'pointer';
  }
  
  if (spotifyNavForward.disabled) {
    spotifyNavForward.style.opacity = 0.5;
    spotifyNavForward.style.cursor = 'default';
  } else {
    spotifyNavForward.style.opacity = 1;
    spotifyNavForward.style.cursor = 'pointer';
  }
}

// Navigation arri√®re
function navigateBack() {
  if (spotifyNavPosition > 0) {
    isNavigating = true;
    spotifyNavPosition--;
    switchSpotifySection(spotifyNavHistory[spotifyNavPosition]);
    isNavigating = false;
  }
}

// Navigation avant
function navigateForward() {
  if (spotifyNavPosition < spotifyNavHistory.length - 1) {
    isNavigating = true;
    spotifyNavPosition++;
    switchSpotifySection(spotifyNavHistory[spotifyNavPosition]);
    isNavigating = false;
  }
}

// Charger les r√©cemment √©cout√©s
function loadRecentlyPlayed() {
  const recentItemsContainer = document.getElementById('spotify-recent-items');
  
  // Effacer le contenu existant
  recentItemsContainer.innerHTML = '';
  
  // Si aucun √©l√©ment r√©cent, afficher un message
  if (spotifyRecentlyPlayed.length === 0) {
    recentItemsContainer.innerHTML = '<div style="color: #b3b3b3; padding: 20px;">Aucune r√©citation √©cout√©e r√©cemment</div>';
    return;
  }
  
  // Afficher les √©l√©ments r√©cents (limit√©s aux 6 derniers)
  spotifyRecentlyPlayed.slice(0, 6).forEach(item => {
    const recentItem = document.createElement('div');
    recentItem.className = 'spotify-recent-item';
    
    // S'assurer que l'URL de l'image est valide, sinon utiliser l'image par d√©faut
    const imgUrl = item.reciterImgUrl || 'assets/images/reciters/default_reciter.jpg';
    
    recentItem.innerHTML = `
      <img src="${imgUrl}" class="spotify-recent-item-img" alt="${item.surahName}" onerror="this.src='assets/images/reciters/default_reciter.jpg'">
      <div class="spotify-recent-item-title">${item.surahName}</div>
      <div class="spotify-recent-item-subtitle">${item.reciterName}</div>
    `;
    
    // Cliquer sur un √©l√©ment r√©cent pour le jouer
    recentItem.addEventListener('click', () => {
      if (currentReciter && currentReciter.id !== item.reciterId) {
        // Charger d'abord le r√©citateur
        const reciter = allReciters.find(r => r.id === item.reciterId);
        if (reciter) {
          selectReciter(reciter, imgUrl).then(() => {
            // Puis jouer la sourate
            const surah = spotifyAllSurahs.find(s => s.id === item.surahId);
            if (surah) {
              playSurah(surah, reciter.api_reciter_id);
            }
          });
        }
      } else {
        // Jouer directement la sourate si le r√©citateur est d√©j√† charg√©
        const surah = spotifyAllSurahs.find(s => s.id === item.surahId);
        if (surah) {
          playSurah(surah, item.apiReciterId);
        }
      }
    });
    
    recentItemsContainer.appendChild(recentItem);
  });
}

// Charger les favoris
function loadFavorites() {
  const favoritesContainer = document.getElementById('spotify-favorites-container');
  
  // Effacer le contenu existant
  favoritesContainer.innerHTML = '';
  
  // Charger les favoris depuis le stockage local s'ils existent
  const savedFavorites = localStorage.getItem('spotifyFavorites');
  if (savedFavorites) {
    spotifyFavorites = JSON.parse(savedFavorites);
  }
  
  // Si aucun favori, afficher un message
  if (spotifyFavorites.length === 0) {
    favoritesContainer.innerHTML = '<div style="color: #b3b3b3; padding: 20px;">Aucun favori</div>';
    return;
  }
  
  // Afficher les favoris
  spotifyFavorites.forEach(favorite => {
    const favoriteItem = document.createElement('div');
    favoriteItem.className = 'spotify-playlist-item';
    
    // S'assurer que l'URL de l'image est valide
    const imgUrl = favorite.reciterImgUrl || 'assets/images/reciters/default_reciter.jpg';
    
    favoriteItem.innerHTML = `
      <img src="${imgUrl}" class="spotify-playlist-img" alt="${favorite.surahName}" onerror="this.src='assets/images/reciters/default_reciter.jpg'">
      <div class="spotify-playlist-title">${favorite.surahName}</div>
      <div class="spotify-playlist-subtitle">${favorite.reciterName}</div>
    `;
    
    // Cliquer sur un favori pour le jouer
    favoriteItem.addEventListener('click', () => {
      if (currentReciter && currentReciter.id !== favorite.reciterId) {
        // Charger d'abord le r√©citateur
        const reciter = allReciters.find(r => r.id === favorite.reciterId);
        if (reciter) {
          selectReciter(reciter, imgUrl).then(() => {
            // Puis jouer la sourate
            const surah = spotifyAllSurahs.find(s => s.id === favorite.surahId);
            if (surah) {
              playSurah(surah, reciter.api_reciter_id);
            }
          });
      }
    } else {
        // Jouer directement la sourate si le r√©citateur est d√©j√† charg√©
        const surah = spotifyAllSurahs.find(s => s.id === favorite.surahId);
        if (surah) {
          playSurah(surah, favorite.apiReciterId);
        }
      }
    });
    
    favoritesContainer.appendChild(favoriteItem);
  });
}

// Ajouter aux favoris
function addToFavorites(surah, reciter) {
  // V√©rifier si ce favori existe d√©j√†
  const existingIndex = spotifyFavorites.findIndex(f => 
    f.surahId === surah.id && f.reciterId === reciter.id
  );
  
  if (existingIndex !== -1) {
    // D√©j√† dans les favoris, on le supprime
    spotifyFavorites.splice(existingIndex, 1);
    showNotification('Retir√© des favoris', 'info');
  } else {
    // Nouveau favori
    const newFavorite = {
    surahId: surah.id,
    surahName: surah.name_simple,
    reciterId: reciter.id,
    reciterName: reciter.reciter_name,
    apiReciterId: reciter.api_reciter_id,
      reciterImgUrl: reciter.image || 'https://i.scdn.co/image/ab67616d0000b2731527816a1d47daa8b7519f46',
    timestamp: Date.now()
  };
  
    spotifyFavorites.push(newFavorite);
    showNotification('Ajout√© aux favoris', 'success');
  }
  
  // Sauvegarder dans le stockage local
  localStorage.setItem('spotifyFavorites', JSON.stringify(spotifyFavorites));
  
  // Mettre √† jour l'affichage des favoris si visible
  if (!spotifyFavoritesSection.classList.contains('hidden')) {
    loadFavorites();
  }
  
  // Mettre √† jour l'√©tat du bouton like si la sourate en cours est concern√©e
  updateLikeButtonState();
}

// Mettre √† jour l'√©tat du bouton like
function updateLikeButtonState() {
  if (!currentSurahPlaying || !currentReciter) {
    spotifyLikeButton.classList.remove('active');
    return;
  }
  
  // V√©rifier si la sourate en cours est dans les favoris
  const isFavorite = spotifyFavorites.some(f => 
    f.surahId === currentSurahPlaying.id && f.reciterId === currentReciter.id
  );
  
  if (isFavorite) {
    spotifyLikeButton.classList.add('active');
  } else {
    spotifyLikeButton.classList.remove('active');
  }
}

// Charger les playlists
function loadPlaylists() {
  const playlistsContainer = document.getElementById('spotify-playlists-container');
  
  // Effacer le contenu existant
  playlistsContainer.innerHTML = '';
  
  // Charger les playlists depuis le stockage local s'ils existent
  const savedPlaylists = localStorage.getItem('spotifyPlaylists');
  if (savedPlaylists) {
    spotifyPlaylists = JSON.parse(savedPlaylists);
  }
  
  // Si aucune playlist, afficher un message
  if (spotifyPlaylists.length === 0) {
    playlistsContainer.innerHTML = '<div style="color: #b3b3b3; padding: 20px;">Aucune playlist</div>';
    return;
  }
  
  // Afficher les playlists
  spotifyPlaylists.forEach(playlist => {
    const playlistItem = document.createElement('div');
    playlistItem.className = 'spotify-playlist-item';
    
    // Utiliser une image g√©n√©rique pour les playlists
    playlistItem.innerHTML = `
      <div class="spotify-playlist-img">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 18V5l12-2v13"></path>
          <circle cx="6" cy="18" r="3"></circle>
          <circle cx="18" cy="16" r="3"></circle>
        </svg>
      </div>
      <div class="spotify-playlist-title">${playlist.name}</div>
      <div class="spotify-playlist-subtitle">${playlist.items.length} sourates</div>
    `;
    
    // Cliquer sur une playlist pour afficher son contenu
    playlistItem.addEventListener('click', () => {
      showPlaylistDetails(playlist);
    });
    
    playlistsContainer.appendChild(playlistItem);
  });
}

// Cr√©er une nouvelle playlist
function createNewPlaylist() {
  const playlistName = prompt('Nom de la nouvelle playlist:');
  
  if (!playlistName || playlistName.trim() === '') {
      return;
  }
  
  // Cr√©er la nouvelle playlist
  const newPlaylist = {
    id: Date.now(),
    name: playlistName.trim(),
    items: [],
    createdAt: Date.now()
  };
  
  // Ajouter √† la liste des playlists
  spotifyPlaylists.push(newPlaylist);
  
  // Sauvegarder dans le stockage local
  localStorage.setItem('spotifyPlaylists', JSON.stringify(spotifyPlaylists));
  
  // Mettre √† jour l'affichage
  loadPlaylists();
  
  // Afficher la nouvelle playlist
}

// Afficher une notification
function showNotification(message, type = 'info') {
  // Cr√©er l'√©l√©ment de notification s'il n'existe pas
  let notification = document.getElementById('spotify-notification');
  
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'spotify-notification';
    notification.className = 'spotify-notification';
    document.body.appendChild(notification);
  }
  
  // D√©finir la classe selon le type
  notification.className = `spotify-notification ${type}`;
  
  // D√©finir le message
  notification.textContent = message;
  
  // Afficher la notification
  notification.classList.add('show');
  
  // La masquer apr√®s 3 secondes
  setTimeout(() => {
    notification.classList.remove('show');
    
    // Supprimer l'√©l√©ment apr√®s la fin de l'animation
    setTimeout(() => {
      if (notification.parentNode) {
        document.body.removeChild(notification);
      }
    }, 300);
  }, 3000);
}

// Variable pour √©viter les doubles navigations
let isNavigating = false;

// Variables globales pour la gestion de la lecture
let spotifyQueue = [];
let isShuffleEnabled = false;
// Suppression de la d√©claration en double de repeatMode

// Fonction pour activer/d√©sactiver le mode shuffle
function toggleShuffle() {
  isShuffleEnabled = !isShuffleEnabled;
  const shuffleButton = document.getElementById('spotify-shuffle');
  shuffleButton.classList.toggle('active', isShuffleEnabled);
  
  if (isShuffleEnabled && spotifyAllSurahs.length > 0) {
    // M√©langer la liste des sourates
    spotifyAllSurahs = spotifyAllSurahs.sort(() => Math.random() - 0.5);
    showNotification('Lecture al√©atoire activ√©e', 'info');
  } else {
    // Remettre la liste dans l'ordre
    spotifyAllSurahs = spotifyAllSurahs.sort((a, b) => a.id - b.id);
    showNotification('Lecture al√©atoire d√©sactiv√©e', 'info');
  }
}

// Fonction pour changer le mode de r√©p√©tition
function toggleRepeat() {
  const repeatButton = document.getElementById('spotify-repeat');
  const modes = ['none', 'all', 'one'];
  const currentIndex = modes.indexOf(repeatMode);
  repeatMode = modes[(currentIndex + 1) % modes.length];
  
  // Mettre √† jour l'ic√¥ne et le style
  repeatButton.classList.remove('active', 'repeat-one');
  if (repeatMode === 'one') {
    repeatButton.classList.add('repeat-one');
    showNotification('R√©p√©ter la sourate', 'info');
  } else if (repeatMode === 'all') {
    repeatButton.classList.add('active');
      showNotification('R√©p√©ter toutes les sourates', 'info');
  } else {
      showNotification('R√©p√©tition d√©sactiv√©e', 'info');
  }
}

// Fonction pour g√©rer la fin de lecture
function onSpotifyAudioEnded() {
  if (repeatMode === 'one') {
    // Rejouer la m√™me sourate
    spotifyAudioElement.currentTime = 0;
    spotifyAudioElement.play();
  } else if (repeatMode === 'all' || spotifyQueue.length > 0) {
    // Passer √† la suivante ou rejouer depuis le d√©but
    playNextSurah();
  }
}

// Fonction pour ajouter une sourate √† la queue
function addToQueue(surah, reciterId) {
  spotifyQueue.push({ surah, reciterId });
  if (spotifyQueue.length === 1 && !spotifyAudioElement.src) {
    playFromQueue();
  }
}

// Fonction pour jouer depuis la queue
function playFromQueue() {
  if (spotifyQueue.length === 0) return;
  
  const { surah, reciterId } = spotifyQueue[0];
  playSurah(surah, reciterId);
  spotifyQueue.shift();
}

// Fonction pour activer/d√©sactiver le mini-player
function toggleMiniPlayer() {
  const playerModal = document.getElementById('spotify-player-modal');
  const miniPlayerToggle = document.getElementById('spotify-mini-player-toggle');
  
  if (playerModal.classList.contains('mini-player')) {
    // Retour au mode normal
    playerModal.classList.remove('mini-player');
    miniPlayerToggle.classList.remove('active');
    showNotification('Mode normal', 'info');
  } else {
    // Activer le mini-player
    playerModal.classList.add('mini-player');
    miniPlayerToggle.classList.add('active');
    showNotification('Mini-player activ√©', 'info');
  }
}

// Mettre √† jour l'√©v√©nement du bouton mini-player
spotifyMiniPlayerToggle.addEventListener('click', toggleMiniPlayer);

// Ajouter ces styles au d√©but du fichier apr√®s les autres d√©clarations de style
const downloadButtonStyles = document.createElement('style');
downloadButtonStyles.textContent = `
  /* Styles pour le bouton de t√©l√©chargement */
  .button.dark-single {
    --background: none;
    --rectangle: #555; /* Gris par d√©faut (non t√©l√©charg√©) */
    --success: #4BC793;
    --arrow: #fff;
    --checkmark: #fff;
    transition: all 0.3s ease;
    opacity: 1; /* Toujours 100% visible */
    display: block !important; /* Forcer l'affichage */
  }
  
  /* Style quand t√©l√©charg√© */
  .button.dark-single.downloaded {
    --rectangle: #4BC793; /* Vert quand t√©l√©charg√© */
    opacity: 0.85; /* L√©g√®rement transparent quand t√©l√©charg√© */
  }
  
  /* Style pendant le t√©l√©chargement */
  .button.dark-single.loading {
    --rectangle: #275efe; /* Bleu pendant le t√©l√©chargement */
    opacity: 1; /* 100% visible pendant le t√©l√©chargement */
  }
  
  /* Style au survol pour indiquer l'interactivit√© */
  .button.dark-single:hover {
    transform: scale(1.1);
    opacity: 1;
  }
  
  /* S'assurer que le bouton est toujours visible dans la liste des sourates */
  .spotify-surah-item .button.dark-single {
    visibility: visible !important;
    display: flex !important;
    opacity: 1 !important;
  }
  
  /* Ajouter plus d'espace entre la colonne DUR√âE et les boutons */
  .spotify-surah-duration {
    margin-left: 40px !important;
    min-width: 60px !important;
    text-align: right !important;
  }
  
  /* Ajuster l'en-t√™te DUR√âE √©galement */
  .spotify-header .dur√©e {
    margin-left: 40px !important;
    text-align: right !important;
  }
  
  /* Ajouter plus d'espace sur toute la ligne */
  .spotify-surah-item {
    grid-template-columns: 30px 1fr auto 80px auto !important;
    column-gap: 15px !important;
  }
`;
document.head.appendChild(downloadButtonStyles);

// Fonction pour charger les dur√©es r√©elles des sourates en arri√®re-plan
async function loadSurahDurationsInBackground() {
  console.log('Chargement des dur√©es des sourates en arri√®re-plan...');
  
  // V√©rifier si les dur√©es sont d√©j√† en cache
  const cachedDurations = localStorage.getItem('surahDurations');
  if (cachedDurations) {
    console.log('Dur√©es des sourates trouv√©es dans le cache');
    return JSON.parse(cachedDurations);
  }
  
  // Si pas de cache, cr√©er un objet pour stocker les dur√©es
  const durations = {};
  
  // R√©cup√©rer tous les r√©citateurs disponibles
  try {
    const recitersResponse = await fetch('https://api.quran.com/api/v4/resources/recitations');
    const recitersData = await recitersResponse.json();
    
    if (recitersData && recitersData.recitations && recitersData.recitations.length > 0) {
      // Utiliser le premier r√©citateur pour obtenir les dur√©es
      const reciterId = recitersData.recitations[0].id;
      
      // R√©cup√©rer toutes les sourates
      const surahsResponse = await fetch('https://api.quran.com/api/v4/chapters');
      const surahsData = await surahsResponse.json();
      
      if (surahsData && surahsData.chapters) {
        // Limiter √† 10 sourates pour ne pas surcharger l'API
        const limitedSurahs = surahsData.chapters.slice(0, 10);
        
        // Charger les dur√©es pour chaque sourate
        for (const surah of limitedSurahs) {
          try {
            const endpoint = `https://api.quran.com/api/v4/chapter_recitations/${reciterId}/${surah.id}`;
            const response = await fetch(endpoint);
            
            if (response.ok) {
              const data = await response.json();
              
              if (data.audio_file && data.audio_file.audio_url) {
                // Cr√©er un √©l√©ment audio temporaire pour obtenir la dur√©e
                const tempAudio = new Audio();
                
                // Utiliser une promesse pour attendre que les m√©tadonn√©es soient charg√©es
                const duration = await new Promise((resolve) => {
                  tempAudio.onloadedmetadata = function() {
                    resolve(formatTime(tempAudio.duration));
                  };
                  
                  tempAudio.onerror = function() {
                    resolve("--:--");
                  };
                  
                  // Charger l'URL audio pour obtenir sa dur√©e
                  tempAudio.src = data.audio_file.audio_url;
                  
                  // Timeout pour √©viter de bloquer ind√©finiment
                  setTimeout(() => resolve("--:--"), 5000);
                });
                
                // Stocker la dur√©e
                durations[surah.id] = duration;
                console.log(`Dur√©e de la sourate ${surah.id}: ${duration}`);
              }
            }
            
            // Attendre un peu entre chaque requ√™te pour ne pas surcharger l'API
            await new Promise(resolve => setTimeout(resolve, 500));
      } catch (error) {
            console.error(`Erreur lors du chargement de la dur√©e de la sourate ${surah.id}:`, error);
            durations[surah.id] = "--:--";
          }
        }
        
        // Sauvegarder les dur√©es dans le localStorage
        localStorage.setItem('surahDurations', JSON.stringify(durations));
        console.log('Dur√©es des sourates sauvegard√©es dans le cache');
        
        return durations;
      }
    }
  } catch (error) {
    console.error('Erreur lors du chargement des dur√©es des sourates:', error);
  }
  
  return {};
}

// Lancer le chargement des dur√©es en arri√®re-plan au d√©marrage
document.addEventListener('DOMContentLoaded', () => {
  // Charger les dur√©es des sourates en arri√®re-plan
  loadSurahDurationsInBackground().then(durations => {
    console.log('Dur√©es des sourates charg√©es:', durations);
    
    // Mettre √† jour les dur√©es affich√©es
    updateSurahDurations();
    
    // Mettre √† jour les dur√©es toutes les 5 secondes pour s'assurer qu'elles sont affich√©es
    // m√™me si la liste est charg√©e apr√®s le chargement des dur√©es
    let updateCount = 0;
    const updateInterval = setInterval(() => {
      updateSurahDurations();
      updateCount++;
      
      // Arr√™ter apr√®s 10 tentatives (50 secondes)
      if (updateCount >= 10) {
        clearInterval(updateInterval);
      }
    }, 5000);
  });
});

// Fonction pour mettre √† jour les dur√©es affich√©es dans la liste des sourates
function updateSurahDurations() {
  // R√©cup√©rer les dur√©es du cache
  const cachedDurations = localStorage.getItem('surahDurations');
  if (!cachedDurations) return;
  
  const durations = JSON.parse(cachedDurations);
  
  // Mettre √† jour les dur√©es affich√©es
  const surahItems = document.querySelectorAll('.spotify-surah-item');
  surahItems.forEach(item => {
    const surahId = item.dataset.surahId;
    if (durations[surahId]) {
      const durationElement = item.querySelector('div:nth-child(4)');
      if (durationElement) {
        durationElement.textContent = durations[surahId];
      }
    }
  });
}

// Lancer le chargement des dur√©es en arri√®re-plan au d√©marrage
document.addEventListener('DOMContentLoaded', () => {
  // Charger les dur√©es des sourates en arri√®re-plan
  loadSurahDurationsInBackground().then(durations => {
    console.log('Dur√©es des sourates charg√©es:', durations);
    
    // Mettre √† jour les dur√©es affich√©es
    updateSurahDurations();
    
    // Mettre √† jour les dur√©es toutes les 5 secondes pour s'assurer qu'elles sont affich√©es
    // m√™me si la liste est charg√©e apr√®s le chargement des dur√©es
    let updateCount = 0;
    const updateInterval = setInterval(() => {
      updateSurahDurations();
      updateCount++;
      
      // Arr√™ter apr√®s 10 tentatives (50 secondes)
      if (updateCount >= 10) {
        clearInterval(updateInterval);
      }
    }, 5000);
  });
});

// Fonction pour obtenir la dur√©e r√©elle d'une sourate
async function getSurahDuration(surahId, reciterId) {
  try {
    // V√©rifier d'abord dans le cache
    const cachedDurations = localStorage.getItem('surahDurations');
    if (cachedDurations) {
      const durations = JSON.parse(cachedDurations);
      if (durations[surahId]) {
        return durations[surahId];
      }
    }
    
    // Si pas dans le cache, r√©cup√©rer depuis l'API
    const endpoint = `https://api.quran.com/api/v4/chapter_recitations/${reciterId}/${surahId}`;
    const response = await fetch(endpoint);
    
    if (response.ok) {
      const data = await response.json();
      
      if (data.audio_file && data.audio_file.audio_url) {
        // Cr√©er un √©l√©ment audio temporaire pour obtenir la dur√©e
        const tempAudio = new Audio();
        
        // Utiliser une promesse pour attendre que les m√©tadonn√©es soient charg√©es
        const duration = await new Promise((resolve) => {
          tempAudio.onloadedmetadata = function() {
            resolve(formatTime(tempAudio.duration));
          };
          
          tempAudio.onerror = function() {
            resolve("--:--");
          };
          
          // Charger l'URL audio pour obtenir sa dur√©e
          tempAudio.src = data.audio_file.audio_url;
          
          // Timeout pour √©viter de bloquer ind√©finiment
          setTimeout(() => resolve("--:--"), 5000);
        });
        
        // Mettre en cache la dur√©e
        if (cachedDurations) {
          const durations = JSON.parse(cachedDurations);
          durations[surahId] = duration;
          localStorage.setItem('surahDurations', JSON.stringify(durations));
        } else {
          const durations = {};
          durations[surahId] = duration;
          localStorage.setItem('surahDurations', JSON.stringify(durations));
        }
        
        return duration;
      }
    }
  } catch (error) {
    console.error(`Erreur lors de la r√©cup√©ration de la dur√©e de la sourate ${surahId}:`, error);
  }
  
  return "--:--";
}

// Modifier la fonction renderSurahs pour utiliser les dur√©es r√©elles
function renderSurahs(surahs, reciterId) {
  // Clear previous content
  spotifySurahListElement.innerHTML = '';
  
  surahs.forEach((surah) => {
    // Utiliser une dur√©e par d√©faut en attendant la dur√©e r√©elle
    const duration = "...";
    
    const surahItem = document.createElement('div');
    surahItem.className = 'spotify-surah-item';
    surahItem.dataset.surahId = surah.id;
    surahItem.dataset.reciterId = reciterId;
    
    // V√©rifier si cette sourate est d√©j√† t√©l√©charg√©e
    const isOffline = checkOfflineAvailability(surah.id);
    
    surahItem.innerHTML = `
      <div class="spotify-surah-number">${surah.id}</div>
      <div>
        <div class="spotify-surah-name">${surah.name_simple}</div>
        <div class="spotify-surah-name-ar">${surah.name_arabic}</div>
      </div>
      <div style="display: flex; justify-content: center; align-items: center;">
        <button class="button dark-single spotify-download-button ${isOffline ? 'downloaded' : ''}" 
          data-surah-id="${surah.id}" 
          data-reciter-id="${reciterId}" 
          title="${isOffline ? 'D√©j√† t√©l√©charg√©e' : 'T√©l√©charger la sourate'}"
          style="width: 32px; height: 32px; border: none;"
          onclick="event.stopPropagation(); event.preventDefault(); return false;">
          <div>
              <svg viewBox="0 0 24 24">
                ${isOffline 
                  ? '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>'
                  : '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>'
                }
          </svg>
          </div>
          <div class="download-progress-container">
            <div class="download-progress-bar"></div>
          </div>
        </button>
      </div>
      <div style="display: flex; justify-content: center; align-items: center; text-align: center;" class="surah-duration" data-surah-id="${surah.id}">${duration}</div>
      <button class="spotify-surah-play">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
      </button>
    `;
    
    // --- Ajout du listener d'animation pour CE bouton ---
    const downloadButton = surahItem.querySelector('.spotify-download-button');
    if (downloadButton) {
        downloadButton.addEventListener('click', function(e) {
        e.stopPropagation();
        e.preventDefault();
        
            // Si d√©j√† t√©l√©charg√©, juste montrer une notification
            if (isOffline || downloadButton.classList.contains('downloaded')) {
                console.log('Cette sourate est d√©j√† t√©l√©charg√©e');
                showNotification('Sourate d√©j√† disponible hors ligne', 'info');
                return false;
            }
            
            // Ajouter la classe loading et commencer le t√©l√©chargement
            downloadButton.classList.add('loading');
            
            // Mettre √† jour le SVG pour l'animation de t√©l√©chargement
            const svg = downloadButton.querySelector('svg');
            if (svg) {
                svg.innerHTML = '<path d="M12 16l-4-4h3V4h2v8h3l-4 4zm-8 2v-6h2v4h12v-4h2v6H4z" fill="var(--arrow, white)"/>';
            }
            
            // Lancer le t√©l√©chargement
            if (typeof downloadSurahAudio === 'function') {
                const surahId = parseInt(downloadButton.dataset.surahId);
                const reciterId = parseInt(downloadButton.dataset.reciterId);
                
                console.log(`T√©l√©chargement de la sourate ${surahId} (r√©citateur ${reciterId})`);
                
                downloadSurahAudio(surahId, reciterId, downloadButton)
                    .then(() => {
                        // Mise √† jour r√©ussie - mettre √† jour l'ic√¥ne et la classe
                        downloadButton.classList.remove('loading');
                        downloadButton.classList.add('downloaded');
                        if (svg) {
                            svg.innerHTML = '<path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" fill="var(--checkmark, white)"/>';
                        }
                        downloadButton.title = 'T√©l√©chargement termin√©';
                    })
                    .catch(error => {
                        console.error(`Erreur de t√©l√©chargement:`, error);
                        downloadButton.classList.remove('loading');
                        if (svg) {
                            svg.innerHTML = '<path d="M12 4v12m-4-4l4 4 4-4" stroke="var(--arrow, white)" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>';
                        }
                        showNotification('Erreur de t√©l√©chargement', 'error');
                    });
            }
            
            return false; // Emp√™cher la propagation
        }, true); // Phase de capture
    }
    
    // Play button click event
    surahItem.querySelector('.spotify-surah-play').addEventListener('click', (e) => {
        e.stopPropagation();
        playSurah(surah, reciterId);
      });
    
    // Entire row click event
    surahItem.addEventListener('click', () => {
      playSurah(surah, reciterId);
    });
    
    spotifySurahListElement.appendChild(surahItem);
    
    // Charger la dur√©e r√©elle en arri√®re-plan
    getSurahDuration(surah.id, reciterId).then(realDuration => {
      const durationElement = document.querySelector(`.surah-duration[data-surah-id="${surah.id}"]`);
      if (durationElement) {
        durationElement.textContent = realDuration;
      }
    });
  });
}

// ... existing code ...

// Fonction pour v√©rifier et reprendre les t√©l√©chargements interrompus
async function checkPendingDownloads() {
  try {
    const pendingDownload = localStorage.getItem('pendingDownload');
    if (!pendingDownload) return;
    
    const downloadInfo = JSON.parse(pendingDownload);
    const { surahId, reciterId, progress, timestamp, downloadedVersets } = downloadInfo;
    
    // V√©rifier si le t√©l√©chargement date de moins de 24h
    const downloadDate = new Date(timestamp);
    const now = new Date();
    const hoursDiff = (now - downloadDate) / (1000 * 60 * 60);
    
    if (hoursDiff > 24) {
      console.log("T√©l√©chargement trop ancien, suppression");
      localStorage.removeItem('pendingDownload');
      return;
    }
    
    // Trouver le bouton de t√©l√©chargement correspondant
    const downloadButton = document.querySelector(`.spotify-download-button[data-surah-id="${surahId}"]`);
    if (!downloadButton) {
      console.log("Bouton de t√©l√©chargement non trouv√©");
      return;
    }
    
    // Demander √† l'utilisateur s'il veut reprendre le t√©l√©chargement
    const shouldResume = await showConfirmDialog(
      'T√©l√©chargement interrompu',
      `Un t√©l√©chargement de la sourate ${surahId} a √©t√© interrompu √† ${progress}%. Voulez-vous le reprendre ?`
    );
    
    if (shouldResume) {
      // Reprendre le t√©l√©chargement
      downloadSurahAudio(surahId, reciterId, downloadButton);
    } else {
      // Supprimer les donn√©es de t√©l√©chargement
      localStorage.removeItem('pendingDownload');
    }
        
      } catch (error) {
    console.error("Erreur lors de la v√©rification des t√©l√©chargements en attente:", error);
    localStorage.removeItem('pendingDownload');
  }
}

// Fonction pour afficher une bo√Æte de dialogue de confirmation
function showConfirmDialog(title, message) {
  return new Promise((resolve) => {
    const dialog = document.createElement('div');
    dialog.className = 'spotify-dialog';
    dialog.innerHTML = `
      <div class="spotify-dialog-content">
        <h3>${title}</h3>
        <p>${message}</p>
        <div class="spotify-dialog-buttons">
          <button class="spotify-dialog-button spotify-dialog-cancel">Annuler</button>
          <button class="spotify-dialog-button spotify-dialog-confirm">Reprendre</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(dialog);
    
    // G√©rer les clics sur les boutons
    dialog.querySelector('.spotify-dialog-cancel').addEventListener('click', () => {
      dialog.remove();
      resolve(false);
    });
    
    dialog.querySelector('.spotify-dialog-confirm').addEventListener('click', () => {
      dialog.remove();
      resolve(true);
    });
  });
}

// ... existing code ...